{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 This documentation provides an overview of the API for the routing library. Installation \u00b6 Third party dependency \u00b6 To use as a third party dependency, use the code 3PIDO5P3H4VPEMPL Clone from github \u00b6 Copy the github repo url in the anvil editor, click clone from github.","title":"Overview"},{"location":"#overview","text":"This documentation provides an overview of the API for the routing library.","title":"Overview"},{"location":"#installation","text":"","title":"Installation"},{"location":"#third-party-dependency","text":"To use as a third party dependency, use the code 3PIDO5P3H4VPEMPL","title":"Third party dependency"},{"location":"#clone-from-github","text":"Copy the github repo url in the anvil editor, click clone from github.","title":"Clone from github"},{"location":"api-reference/","text":"Api Reference \u00b6 The routing library provides the following functions, classes and attributes. All attributes can be accessed from the routing.router module. Functions \u00b6 navigate(*, path=None, params=None, query=None, hash=None, replace=False, nav_context=None, form_properties=None) navigate(path, **kws) navigate(url, **kws) navigate(routing_context, **kws) Navigates to a new page. launch() Launches the routing library and navigates to the first route. Call this in your startup module. go(n=0) Navigates to the nth page in the history stack back() Navigates back in the history stack forward() Navigates forward in the history stack reload(hard=False) Reloads the current page. If hard is True then the page will be reloaded from the server. If hard is False then the page will be removed from the cache and reloaded on the client. get_routing_context() Returns the current routing context get_url() get_url(*, path=None, params=None, query=None, hash=None, full=False) get_url(path, **kws) get_url(routing_context, **kws) Gets the url. if no keyword arguments are passed then the current url will be returned. If full is True then the full url will be returned e.g. http://my-app.anvil.app/articles/123?foo=bar#hash . If full is False then the url will be relative to the base url e.g. /articles/123?foo=bar#hash . If no then the current page url will be returned. debug_logging(enable=True) Enables or disables debug logging clear_cache() Clears the cache of forms and data invalidate(*, path=None, deps=None, exact=False) Invalidates any cached data and forms based on the path and deps. The exact argument determines whether to invalidate based on an exact match or a partial match. open_form(form, **form_properties) When migrating you may be able to replace anvil.open_form with router.open_form . This will only work if you are not using params . Classes \u00b6 Route The base class for all routes. RoutingContext Provides information about the current route and navigation context. Passed to all forms instantiated by the routing library. Components \u00b6 NavLink.NavLink A link that you will likely use in your main layout's sidebar. Has an active property that is set when the NavLink's navigation properties match the current routing context. Anchor.Anchor A link that you can use inline, or use as a container for other components. Context Managers \u00b6 NavigationBlocker A context manager that will prevent the user from navigating away during the context. Exceptions \u00b6 Redirect Raise during a route's before_load method to redirect to a different route. NotFound Raised when a route is not found for given path.","title":"Api Reference"},{"location":"api-reference/#api-reference","text":"The routing library provides the following functions, classes and attributes. All attributes can be accessed from the routing.router module.","title":"Api Reference"},{"location":"api-reference/#functions","text":"navigate(*, path=None, params=None, query=None, hash=None, replace=False, nav_context=None, form_properties=None) navigate(path, **kws) navigate(url, **kws) navigate(routing_context, **kws) Navigates to a new page. launch() Launches the routing library and navigates to the first route. Call this in your startup module. go(n=0) Navigates to the nth page in the history stack back() Navigates back in the history stack forward() Navigates forward in the history stack reload(hard=False) Reloads the current page. If hard is True then the page will be reloaded from the server. If hard is False then the page will be removed from the cache and reloaded on the client. get_routing_context() Returns the current routing context get_url() get_url(*, path=None, params=None, query=None, hash=None, full=False) get_url(path, **kws) get_url(routing_context, **kws) Gets the url. if no keyword arguments are passed then the current url will be returned. If full is True then the full url will be returned e.g. http://my-app.anvil.app/articles/123?foo=bar#hash . If full is False then the url will be relative to the base url e.g. /articles/123?foo=bar#hash . If no then the current page url will be returned. debug_logging(enable=True) Enables or disables debug logging clear_cache() Clears the cache of forms and data invalidate(*, path=None, deps=None, exact=False) Invalidates any cached data and forms based on the path and deps. The exact argument determines whether to invalidate based on an exact match or a partial match. open_form(form, **form_properties) When migrating you may be able to replace anvil.open_form with router.open_form . This will only work if you are not using params .","title":"Functions"},{"location":"api-reference/#classes","text":"Route The base class for all routes. RoutingContext Provides information about the current route and navigation context. Passed to all forms instantiated by the routing library.","title":"Classes"},{"location":"api-reference/#components","text":"NavLink.NavLink A link that you will likely use in your main layout's sidebar. Has an active property that is set when the NavLink's navigation properties match the current routing context. Anchor.Anchor A link that you can use inline, or use as a container for other components.","title":"Components"},{"location":"api-reference/#context-managers","text":"NavigationBlocker A context manager that will prevent the user from navigating away during the context.","title":"Context Managers"},{"location":"api-reference/#exceptions","text":"Redirect Raise during a route's before_load method to redirect to a different route. NotFound Raised when a route is not found for given path.","title":"Exceptions"},{"location":"how-it-works/","text":"How It Works \u00b6 Routing Basics \u00b6 As an app developer, you will need to define routes for your app. When the url changes, the router will look for a matching route. The router will try to match routes in the order they are defined. When a route is found, the router will call the route's before_load method. If the before_load method raises a Redirect , the router will navigate to the redirected url. If the route has a load_data method, it will be called and the return value will be available as the data property on the RoutingContext . Once the load_data method has been called, the router will call open_form on the matching route's form. A routing_context will be passed to the form. Caching \u00b6 There are two types of caching, form caching and data caching. If a form is cached, instead of calling the route's load_form method will be called with the cached form instance. If data is cached, the router will only call the load_data method if the data is stale. See caching for more details. Server vs Client Routing \u00b6 The above process will happen on the server, if the user navigates directly to a url (the initial page request). If the user is navigating from within the app, then routing will happen on the client.","title":"How It Works"},{"location":"how-it-works/#how-it-works","text":"","title":"How It Works"},{"location":"how-it-works/#routing-basics","text":"As an app developer, you will need to define routes for your app. When the url changes, the router will look for a matching route. The router will try to match routes in the order they are defined. When a route is found, the router will call the route's before_load method. If the before_load method raises a Redirect , the router will navigate to the redirected url. If the route has a load_data method, it will be called and the return value will be available as the data property on the RoutingContext . Once the load_data method has been called, the router will call open_form on the matching route's form. A routing_context will be passed to the form.","title":"Routing Basics"},{"location":"how-it-works/#caching","text":"There are two types of caching, form caching and data caching. If a form is cached, instead of calling the route's load_form method will be called with the cached form instance. If data is cached, the router will only call the load_data method if the data is stale. See caching for more details.","title":"Caching"},{"location":"how-it-works/#server-vs-client-routing","text":"The above process will happen on the server, if the user navigates directly to a url (the initial page request). If the user is navigating from within the app, then routing will happen on the client.","title":"Server vs Client Routing"},{"location":"quick-start/","text":"Quick Start \u00b6 From a Clone \u00b6 Clone the following Anvil app: https://anvil.works/build#clone:34ZTMM7IQRTCMIAD=PPWCEPHZKQ3VYBIEF6T7GWOY From a New App \u00b6 Create a new app. Client Code Structure \u00b6 The client code structure should look like this: - Layouts (Package) - Main (Form - ensure you tick \"Use as layout\") - Pages (Package) - Index (Form choosing Layouts.Main as the layout) - About (Form choosing Layouts.Main as the layout) - Contact (Form choosing Layouts.Main as the layout) - routes (Module) - startup (Module) Startup Module \u00b6 # startup.py from routing.router import launch from .import routes if __name__ == \"__main__\": launch() Routes Module \u00b6 # routes.py from routing.router import Route class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" class AboutRoute(Route): path = \"/about\" form = \"Pages.About\" class ContactRoute(Route): path = \"/contact\" form = \"Pages.Contact\" Server Routes Module \u00b6 Inside your Server code, create a server module that imports the routes module. # ServerRoutes.py from . import routes You should now be able to run the app and navigate to different pages by changing the URL in the browser. Navigation \u00b6 In Layouts.Main , include a SideBar and add 3 NavLink components. (The NavLink component should come from the routing library) Ensure the nav links have the following properties set: The first NavLink should have the path=\"/\" . The second NavLink should have the path=\"/about\" . The third NavLink should have the path=\"/contact\" . Add a title slot to the Layouts.Main form. And inside Pages.Index , add a label component to the title slot with the text property set to \"Home\" . Do the same for Pages.About and Pages.Contact . You should now be able to navigate using the side bar nav links.","title":"Quick Start"},{"location":"quick-start/#quick-start","text":"","title":"Quick Start"},{"location":"quick-start/#from-a-clone","text":"Clone the following Anvil app: https://anvil.works/build#clone:34ZTMM7IQRTCMIAD=PPWCEPHZKQ3VYBIEF6T7GWOY","title":"From a Clone"},{"location":"quick-start/#from-a-new-app","text":"Create a new app.","title":"From a New App"},{"location":"quick-start/#client-code-structure","text":"The client code structure should look like this: - Layouts (Package) - Main (Form - ensure you tick \"Use as layout\") - Pages (Package) - Index (Form choosing Layouts.Main as the layout) - About (Form choosing Layouts.Main as the layout) - Contact (Form choosing Layouts.Main as the layout) - routes (Module) - startup (Module)","title":"Client Code Structure"},{"location":"quick-start/#startup-module","text":"# startup.py from routing.router import launch from .import routes if __name__ == \"__main__\": launch()","title":"Startup Module"},{"location":"quick-start/#routes-module","text":"# routes.py from routing.router import Route class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" class AboutRoute(Route): path = \"/about\" form = \"Pages.About\" class ContactRoute(Route): path = \"/contact\" form = \"Pages.Contact\"","title":"Routes Module"},{"location":"quick-start/#server-routes-module","text":"Inside your Server code, create a server module that imports the routes module. # ServerRoutes.py from . import routes You should now be able to run the app and navigate to different pages by changing the URL in the browser.","title":"Server Routes Module"},{"location":"quick-start/#navigation","text":"In Layouts.Main , include a SideBar and add 3 NavLink components. (The NavLink component should come from the routing library) Ensure the nav links have the following properties set: The first NavLink should have the path=\"/\" . The second NavLink should have the path=\"/about\" . The third NavLink should have the path=\"/contact\" . Add a title slot to the Layouts.Main form. And inside Pages.Index , add a label component to the title slot with the text property set to \"Home\" . Do the same for Pages.About and Pages.Contact . You should now be able to navigate using the side bar nav links.","title":"Navigation"},{"location":"caching/","text":"Caching \u00b6 The routing library provides simple caching mechanisms for forms and data. By default, the routing library will NOT cache any forms or data. Clearing Cache \u00b6 To clear the cache, you can call the clear_cache function. from routing import router router.clear_cache() Form Caching \u00b6 To override the default behavior, you can set the Route.cache_form attribute to True . This will cause the routing library to cache all forms. from routing.router import Route Route.cache_form = True You can also set this attribute on specific routes. class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" cache_form = True Data Caching \u00b6 The routing library can cache data that was loaded by the load_data method. If you are not using the load_data method, then you can skip this section. For more details see the Data Loading section. You can turn on data caching by setting the cache_data attribute on the route to True . Caching If you are using load_data method and cache_form is set to True , then load_data method will not be called if there is an existing cached form. <!-- Stale While Revalidate \u00b6 A more advanced mode is STALE_WHILE_REVALIDATE . In this mode, the data will be loaded from the cache, and then loaded in the background from the server, if the data is stale. If there is no data in the cache, then the form will not be instantiated until the load_data method returns a value. from routing.router import Route, STALE_WHILE_REVALIDATE Route.cache_data = STALE_WHILE_REVALIDATE Or you can set this attribute on specific routes. class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" cache_data = STALE_WHILE_REVALIDATE If you are using the STALE_WHILE_REVALIDATE mode, then you can customize the caching behavior by setting the Route.stale_time attribute. By default this is 0 seconds. i.e. the data is always considered stale when navigating to the route. When the data is stale, the form will be instantiated with the stale data. The route's load_data method will be called in the background, and when the load_data method returns a value, the routing_context will be updated with the new data and raise the \"data_loaded\" event. from routing import router class ArticlesForm(ArticlesFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.init_components(**properties) self.routing_context = routing_context self.routing_context.add_event_handler(\"data_loaded\", self.on_data_loaded) self.routing_context.raise_init_events() def on_data_loaded(self, **event_args): self.repeating_panel.items = self.routing_context.data ``` --> ## Caching keys The routing library will cache forms and data by a cache key. The key is a combination of the path, and the dictionary returned by the `cache_deps` method. By default the `cache_deps` method returns the `query` dictionary. ## Invalidating Cache If you want to invalidate the cache, you can call the `invalidate` function. Invalidating the cache will remove data and forms from the cache. ```python from routing import router router.invalidate(path=\"/articles\") The call signature for invalidate is: invalidate(*, path=None, deps=None, exact=False) invalidate(path, **kws) invalidate(routing_context, **kws) path The path to invalidate. deps The dependencies to invalidate. These are the same dependencies that are returned by the cache_deps method. exact If True then the path and deps must match exactly. If False (the default) then any path or deps that are a subset of path and deps arguments will be invalidated. Partial Invalidation \u00b6 from routing.router import Route class ArticlesRoute(Route): path = \"/articles\" form = \"Pages.Articles\" class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" In the above example if you call invalidate(\"/articles\", exact=True) then data and forms associated with the ArticlesRoute will be invalidated. If you call invalidate(\"/articles\", exact=False) then data and forms associated with the ArticlesRoute and all cached ArticleRoute will be invalidated since the ArticleRoute path is a subset of the ArticlesRoute path. from routing.router import Route class ArticlesRoute(Route): path = \"/articles\" form = \"Pages.Articles\" def cache_deps(self, **loader_args): return {\"page\": loader_args[\"query\"][\"page\"]} def parse_query(self, query): return {**query, \"page\": int(query.get(\"page\", 1))} In the above example the data is cached depending on the page query parameter. If you call invalidate(\"/articles\") then all data associated with all pages will be invalidated. A deps value of {\"page\": 1} is considered a subset of an empty deps argument. If you call invalidate(\"/articles\", exact=True) then no data will be invalidated, since there is no match. Calling invalidate(\"/articles\", deps={\"page\": 1}) will invalidate only the data for the first page. Invalidating Contexts \u00b6 A routing context also has an invalidate method for convenience. from routing import router class ArticleForm(ArticleFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context self.init_components(**properties) def delete_button_click(self, **event_args): self.remove_from_parent() self.routing_context.invalidate(exact=True)","title":"Caching"},{"location":"caching/#caching","text":"The routing library provides simple caching mechanisms for forms and data. By default, the routing library will NOT cache any forms or data.","title":"Caching"},{"location":"caching/#clearing-cache","text":"To clear the cache, you can call the clear_cache function. from routing import router router.clear_cache()","title":"Clearing Cache"},{"location":"caching/#form-caching","text":"To override the default behavior, you can set the Route.cache_form attribute to True . This will cause the routing library to cache all forms. from routing.router import Route Route.cache_form = True You can also set this attribute on specific routes. class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" cache_form = True","title":"Form Caching"},{"location":"caching/#data-caching","text":"The routing library can cache data that was loaded by the load_data method. If you are not using the load_data method, then you can skip this section. For more details see the Data Loading section. You can turn on data caching by setting the cache_data attribute on the route to True . Caching If you are using load_data method and cache_form is set to True , then load_data method will not be called if there is an existing cached form. <!--","title":"Data Caching"},{"location":"caching/#stale-while-revalidate","text":"A more advanced mode is STALE_WHILE_REVALIDATE . In this mode, the data will be loaded from the cache, and then loaded in the background from the server, if the data is stale. If there is no data in the cache, then the form will not be instantiated until the load_data method returns a value. from routing.router import Route, STALE_WHILE_REVALIDATE Route.cache_data = STALE_WHILE_REVALIDATE Or you can set this attribute on specific routes. class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" cache_data = STALE_WHILE_REVALIDATE If you are using the STALE_WHILE_REVALIDATE mode, then you can customize the caching behavior by setting the Route.stale_time attribute. By default this is 0 seconds. i.e. the data is always considered stale when navigating to the route. When the data is stale, the form will be instantiated with the stale data. The route's load_data method will be called in the background, and when the load_data method returns a value, the routing_context will be updated with the new data and raise the \"data_loaded\" event. from routing import router class ArticlesForm(ArticlesFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.init_components(**properties) self.routing_context = routing_context self.routing_context.add_event_handler(\"data_loaded\", self.on_data_loaded) self.routing_context.raise_init_events() def on_data_loaded(self, **event_args): self.repeating_panel.items = self.routing_context.data ``` --> ## Caching keys The routing library will cache forms and data by a cache key. The key is a combination of the path, and the dictionary returned by the `cache_deps` method. By default the `cache_deps` method returns the `query` dictionary. ## Invalidating Cache If you want to invalidate the cache, you can call the `invalidate` function. Invalidating the cache will remove data and forms from the cache. ```python from routing import router router.invalidate(path=\"/articles\") The call signature for invalidate is: invalidate(*, path=None, deps=None, exact=False) invalidate(path, **kws) invalidate(routing_context, **kws) path The path to invalidate. deps The dependencies to invalidate. These are the same dependencies that are returned by the cache_deps method. exact If True then the path and deps must match exactly. If False (the default) then any path or deps that are a subset of path and deps arguments will be invalidated.","title":"Stale While Revalidate"},{"location":"caching/#partial-invalidation","text":"from routing.router import Route class ArticlesRoute(Route): path = \"/articles\" form = \"Pages.Articles\" class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" In the above example if you call invalidate(\"/articles\", exact=True) then data and forms associated with the ArticlesRoute will be invalidated. If you call invalidate(\"/articles\", exact=False) then data and forms associated with the ArticlesRoute and all cached ArticleRoute will be invalidated since the ArticleRoute path is a subset of the ArticlesRoute path. from routing.router import Route class ArticlesRoute(Route): path = \"/articles\" form = \"Pages.Articles\" def cache_deps(self, **loader_args): return {\"page\": loader_args[\"query\"][\"page\"]} def parse_query(self, query): return {**query, \"page\": int(query.get(\"page\", 1))} In the above example the data is cached depending on the page query parameter. If you call invalidate(\"/articles\") then all data associated with all pages will be invalidated. A deps value of {\"page\": 1} is considered a subset of an empty deps argument. If you call invalidate(\"/articles\", exact=True) then no data will be invalidated, since there is no match. Calling invalidate(\"/articles\", deps={\"page\": 1}) will invalidate only the data for the first page.","title":"Partial Invalidation"},{"location":"caching/#invalidating-contexts","text":"A routing context also has an invalidate method for convenience. from routing import router class ArticleForm(ArticleFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context self.init_components(**properties) def delete_button_click(self, **event_args): self.remove_from_parent() self.routing_context.invalidate(exact=True)","title":"Invalidating Contexts"},{"location":"data-loading/","text":"Data Loading \u00b6 Most apps will not need to use the load_data method and will load data during the form's instantiation, or pass data through form properties. Many of the advantages of data loading can be achieved by using cached forms . An advantage of the data loading mechanism, over loading data during form instantiation, is that it allows data to be sent from the server during the initial page request. However, since the routing library takes advantage of client-side routing after the initial page request, the advantages of data loading is limited to the first page request. Limitations \u00b6 Data caching is determined by the path and the dictionary returned by the cache_deps method. If your App needs to share data between routes then you may find that data caching is not sufficient and result in duplicate data being loaded. You can mitigate duplicate data by using form_properties or nav_context for simple data sharing. Example \u00b6 Without a load_data method # routes.py from routing.router import Route Route.cache_form = True class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" from routing import router class ArticleForm(ArticleFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context if properties.get(\"item\") is None: # the user navigated directly to the form by changing the url properties[\"item\"] = anvil.server.call(\"get_article\", routing_context.params[\"id\"]) self.init_components(**properties) In the above example, if a user goes directly to the url /articles/123 , the initial page request will send the user to the ArticleForm , but there will be no data. The App will then need to make a server call to get the data. Note that during normal navigation, i.e. when the user clicks a link, we can take advantage of the form_properties attribute to ensure we do not load unnecessary data. class RowTemplate(RowTemplateTemplate): def __init__(self, **properties): self.init_components(**properties) def on_button_click(self, **event_args): router.navigate( path=\"/articles/:id\", params={\"id\": self.item[\"id\"]}, form_properties={\"item\": self.item} ) With a load_data method # routes.py from routing.router import Route class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" def load_data(self, **loader_args): row = loader_args.nav_context.get(\"row\") if row is None: id = loader_args[\"path_params\"][\"id\"] row = anvil.server.call(\"get_row\", id) return return row from routing import router class ArticleForm(ArticleFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context properties[\"item\"] = routing_context.data self.init_components(**properties) In the above example, the load_data is called whenever the user navigates. If a user navigates directly to the url /articles/123 , the initial page request will come in, the load_data method will be called (on the server), and the user will be directed to the ArticleForm with the data already loaded. During normal navigation, i.e. when the user clicks a link, we can take advantage of the nav_context (or form_properties ) attribute to ensure we do not make unnecessary server calls during client side navigation. class RowTemplate(RowTemplateTemplate): def __init__(self, **properties): self.init_components(**properties) def on_button_click(self, **event_args): router.navigate( path=\"/articles/:id\", params={\"id\": self.item[\"id\"]}, nav_context={\"row\": self.item} ) Invalidating Data \u00b6 See Invalidating Cache . Pending Form \u00b6 When data is loading for the first time, a user can provide a loading form. This form will be shown during while the data is loading. The pending form is determined by the Route.pending_form attribute. When the data is loading, the routing library will wait for the pending_delay seconds before showing the pending form. It will show the pending form for at least pending_min seconds. from routing.router import Route class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" pending_form = \"Pages.Loading\" pending_delay = 1 # default is 1 pending_min = 0.5 # default is 0.5 A common implementation will be to create a pending form with the same layout as the form. Where the content would be, place a Anvil.Spacer component. Inside the show and hide event handlers, call the anvil.server.loading_indicator.start and anvil.server.loading_indicator.stop functions. from anvil.server import loading_indicator class LoadingForm(LoadingFormTemplate): def __init__(self, **properties): self.init_components(**properties) self.loading_indicator = anvil.server.loading_indicator(self.spacer_1) def show(self, **event_args): self.loading_indicator.start() def hide(self, **event_args): self.loading_indicator.stop()","title":"Data Loading"},{"location":"data-loading/#data-loading","text":"Most apps will not need to use the load_data method and will load data during the form's instantiation, or pass data through form properties. Many of the advantages of data loading can be achieved by using cached forms . An advantage of the data loading mechanism, over loading data during form instantiation, is that it allows data to be sent from the server during the initial page request. However, since the routing library takes advantage of client-side routing after the initial page request, the advantages of data loading is limited to the first page request.","title":"Data Loading"},{"location":"data-loading/#limitations","text":"Data caching is determined by the path and the dictionary returned by the cache_deps method. If your App needs to share data between routes then you may find that data caching is not sufficient and result in duplicate data being loaded. You can mitigate duplicate data by using form_properties or nav_context for simple data sharing.","title":"Limitations"},{"location":"data-loading/#example","text":"Without a load_data method # routes.py from routing.router import Route Route.cache_form = True class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" from routing import router class ArticleForm(ArticleFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context if properties.get(\"item\") is None: # the user navigated directly to the form by changing the url properties[\"item\"] = anvil.server.call(\"get_article\", routing_context.params[\"id\"]) self.init_components(**properties) In the above example, if a user goes directly to the url /articles/123 , the initial page request will send the user to the ArticleForm , but there will be no data. The App will then need to make a server call to get the data. Note that during normal navigation, i.e. when the user clicks a link, we can take advantage of the form_properties attribute to ensure we do not load unnecessary data. class RowTemplate(RowTemplateTemplate): def __init__(self, **properties): self.init_components(**properties) def on_button_click(self, **event_args): router.navigate( path=\"/articles/:id\", params={\"id\": self.item[\"id\"]}, form_properties={\"item\": self.item} ) With a load_data method # routes.py from routing.router import Route class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" def load_data(self, **loader_args): row = loader_args.nav_context.get(\"row\") if row is None: id = loader_args[\"path_params\"][\"id\"] row = anvil.server.call(\"get_row\", id) return return row from routing import router class ArticleForm(ArticleFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context properties[\"item\"] = routing_context.data self.init_components(**properties) In the above example, the load_data is called whenever the user navigates. If a user navigates directly to the url /articles/123 , the initial page request will come in, the load_data method will be called (on the server), and the user will be directed to the ArticleForm with the data already loaded. During normal navigation, i.e. when the user clicks a link, we can take advantage of the nav_context (or form_properties ) attribute to ensure we do not make unnecessary server calls during client side navigation. class RowTemplate(RowTemplateTemplate): def __init__(self, **properties): self.init_components(**properties) def on_button_click(self, **event_args): router.navigate( path=\"/articles/:id\", params={\"id\": self.item[\"id\"]}, nav_context={\"row\": self.item} )","title":"Example"},{"location":"data-loading/#invalidating-data","text":"See Invalidating Cache .","title":"Invalidating Data"},{"location":"data-loading/#pending-form","text":"When data is loading for the first time, a user can provide a loading form. This form will be shown during while the data is loading. The pending form is determined by the Route.pending_form attribute. When the data is loading, the routing library will wait for the pending_delay seconds before showing the pending form. It will show the pending form for at least pending_min seconds. from routing.router import Route class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" pending_form = \"Pages.Loading\" pending_delay = 1 # default is 1 pending_min = 0.5 # default is 0.5 A common implementation will be to create a pending form with the same layout as the form. Where the content would be, place a Anvil.Spacer component. Inside the show and hide event handlers, call the anvil.server.loading_indicator.start and anvil.server.loading_indicator.stop functions. from anvil.server import loading_indicator class LoadingForm(LoadingFormTemplate): def __init__(self, **properties): self.init_components(**properties) self.loading_indicator = anvil.server.loading_indicator(self.spacer_1) def show(self, **event_args): self.loading_indicator.start() def hide(self, **event_args): self.loading_indicator.stop()","title":"Pending Form"},{"location":"migrating/","text":"Migrating \u00b6 From an app that navigates with anvil.open_form \u00b6 Define your routes. If you are not using params in any routes you should be able to replace all calls to anvil.open_form with router.open_form . To begin with make sure to set cached_forms to False . As you decide certain routes should have params you will need to replace router.open_form with router.navigate . The keyword arguments to open_form will be a dictionary you pass to the form_properties argument of navigate . A common gotcha will be that a Form could previously rely on the item property always being passed to the form. But this will not be the case if a user navigates directly to the form. In this case the item property will be None and you will have to fetch the item based on the routing_context . From anvil_extras.routing ( HashRouting ) \u00b6 Define your routes. Each route definition will be similar to the hash routing @route decorator. By default, when a route subclasses from Route the routing library will call anvil.open_form on the matching route's form. For hash routing apps, this is not what you want. Instead you should subclass from TemplateWithContainerRoute and set the template attribute to the template form. from routing.router import TemplateWithContainerRoute as BaseRoute BaseRoute.template = \"MainTemplate\" class IndexRoute(BaseRoute): path = \"/\" form = \"Pages.Index\" If you have a single template in your hash routing app, then set the BaseRoute.template = \"MyTemplate\" . If you have multiple templates, then you can either set the template attribute on individual routes, or define a get_template method on the Route class. set_url_hash \u00b6 Instead of calling hash routing's set_url_hash method, use the navigate function. full_width_row \u00b6 If the route decorator uses full_width_row you should configure the Route.template_container_properties attribute. from routing.router import TemplateWithContainerRoute as BaseRoute BaseRoute.template = \"MainTemplate\" class IndexRoute(BaseRoute): path = \"/\" form = \"Pages.Index\" template_container_properties = {\"full_width_row\": True}","title":"Migrating"},{"location":"migrating/#migrating","text":"","title":"Migrating"},{"location":"migrating/#from-an-app-that-navigates-with-anvilopen_form","text":"Define your routes. If you are not using params in any routes you should be able to replace all calls to anvil.open_form with router.open_form . To begin with make sure to set cached_forms to False . As you decide certain routes should have params you will need to replace router.open_form with router.navigate . The keyword arguments to open_form will be a dictionary you pass to the form_properties argument of navigate . A common gotcha will be that a Form could previously rely on the item property always being passed to the form. But this will not be the case if a user navigates directly to the form. In this case the item property will be None and you will have to fetch the item based on the routing_context .","title":"From an app that navigates with anvil.open_form"},{"location":"migrating/#from-anvil_extrasrouting-hashrouting","text":"Define your routes. Each route definition will be similar to the hash routing @route decorator. By default, when a route subclasses from Route the routing library will call anvil.open_form on the matching route's form. For hash routing apps, this is not what you want. Instead you should subclass from TemplateWithContainerRoute and set the template attribute to the template form. from routing.router import TemplateWithContainerRoute as BaseRoute BaseRoute.template = \"MainTemplate\" class IndexRoute(BaseRoute): path = \"/\" form = \"Pages.Index\" If you have a single template in your hash routing app, then set the BaseRoute.template = \"MyTemplate\" . If you have multiple templates, then you can either set the template attribute on individual routes, or define a get_template method on the Route class.","title":"From anvil_extras.routing (HashRouting)"},{"location":"migrating/#set_url_hash","text":"Instead of calling hash routing's set_url_hash method, use the navigate function.","title":"set_url_hash"},{"location":"migrating/#full_width_row","text":"If the route decorator uses full_width_row you should configure the Route.template_container_properties attribute. from routing.router import TemplateWithContainerRoute as BaseRoute BaseRoute.template = \"MainTemplate\" class IndexRoute(BaseRoute): path = \"/\" form = \"Pages.Index\" template_container_properties = {\"full_width_row\": True}","title":"full_width_row"},{"location":"navigating/","text":"Navigation \u00b6 There are two ways to navigate. The first is with the navigate function, and the second is with a navigation component . Navigating with navigate \u00b6 The navigate function is a function that you will likely call from a click handler. from routing.router import navigate class Form(FormTemplate): def nav_button_click(self, **event_args): navigate(path=\"/articles/:id\", params={\"id\": 123}) Call Signatures \u00b6 navigate(*, path=None, params=None, query=None, hash=None, replace=False, nav_context=None, form_properties=None) use keyword arguments only navigate(path, **kws) the first argument can be the path navigate(url, **kws) the first argument ca be a url navigate(routing_context, **kws) the first argument can be a routing context Arguments \u00b6 path The path to navigate to. e.g. /articles/123 or /articles or /articles/:id . The path can be relative ./ . If not set then the path will be the current path. params The params for the path. e.g. {\"id\": 123} query The query parameters to navigate to. e.g. {\"tab\": \"income\"} hash The hash to navigate to. replace If True then the current url will be replaced with the new url (default is False ). nav_context The nav context to for this navigation. form_properties The form properties to pass to the form when it is opened. Use of form_properties \u00b6 The form_properties is a dictionary that is passed to the open_form function. A common use case is to pass the form's item property. Note that if you are relying on form_properties you will always need to account for form_properties being an empty dictionary, when the user navigates by changing the url directly. from routing import router class RowTemplate(RowTemplateTemplate): def __init__(self, **properties): self.init_components(**properties) def button_click(self, **event_args): router.navigate(path=\"/articles/:id\", params={\"id\": self.item[\"id\"]}, form_properties={\"item\": self.item}) And then in the /articles/:id route: from routing import router class ArticleForm(ArticleFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context if properties.get(\"item\") is None: # the user navigated directly to the form by changing the url properties[\"item\"] = anvil.server.call(\"get_article\", routing_context.params[\"id\"]) self.init_components(**properties) Use of nav_context \u00b6 The nav_context is a dictionary that is passed to the navigate function. A use case for this is to pass the previous routing context to the next routing context. This is useful when you want to navigate to a new route, but you want to preserve the previous route's data. Particularly if the previous route uses query parameters that determine the state of the form. from routing import router def on_button_click(self, **event_args): current_context = router.get_routing_context() router.navigate(path=\"/foo\", nav_context={\"prev_context\": current_context}) And then in the /foo route: from routing import router class FooForm(FooFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context self.init_components(**properties) def cancel_button_click(self, **event_args): prev_context = self.routing_context.nav_context.get(\"prev_context\") if prev_context is not None: router.navigate(prev_context) else: # no nav-context - the user navigated directly to the form by changing the url router.navigate(path=\"/\")","title":"Navigation"},{"location":"navigating/#navigation","text":"There are two ways to navigate. The first is with the navigate function, and the second is with a navigation component .","title":"Navigation"},{"location":"navigating/#navigating-with-navigate","text":"The navigate function is a function that you will likely call from a click handler. from routing.router import navigate class Form(FormTemplate): def nav_button_click(self, **event_args): navigate(path=\"/articles/:id\", params={\"id\": 123})","title":"Navigating with navigate"},{"location":"navigating/#call-signatures","text":"navigate(*, path=None, params=None, query=None, hash=None, replace=False, nav_context=None, form_properties=None) use keyword arguments only navigate(path, **kws) the first argument can be the path navigate(url, **kws) the first argument ca be a url navigate(routing_context, **kws) the first argument can be a routing context","title":"Call Signatures"},{"location":"navigating/#arguments","text":"path The path to navigate to. e.g. /articles/123 or /articles or /articles/:id . The path can be relative ./ . If not set then the path will be the current path. params The params for the path. e.g. {\"id\": 123} query The query parameters to navigate to. e.g. {\"tab\": \"income\"} hash The hash to navigate to. replace If True then the current url will be replaced with the new url (default is False ). nav_context The nav context to for this navigation. form_properties The form properties to pass to the form when it is opened.","title":"Arguments"},{"location":"navigating/#use-of-form_properties","text":"The form_properties is a dictionary that is passed to the open_form function. A common use case is to pass the form's item property. Note that if you are relying on form_properties you will always need to account for form_properties being an empty dictionary, when the user navigates by changing the url directly. from routing import router class RowTemplate(RowTemplateTemplate): def __init__(self, **properties): self.init_components(**properties) def button_click(self, **event_args): router.navigate(path=\"/articles/:id\", params={\"id\": self.item[\"id\"]}, form_properties={\"item\": self.item}) And then in the /articles/:id route: from routing import router class ArticleForm(ArticleFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context if properties.get(\"item\") is None: # the user navigated directly to the form by changing the url properties[\"item\"] = anvil.server.call(\"get_article\", routing_context.params[\"id\"]) self.init_components(**properties)","title":"Use of form_properties"},{"location":"navigating/#use-of-nav_context","text":"The nav_context is a dictionary that is passed to the navigate function. A use case for this is to pass the previous routing context to the next routing context. This is useful when you want to navigate to a new route, but you want to preserve the previous route's data. Particularly if the previous route uses query parameters that determine the state of the form. from routing import router def on_button_click(self, **event_args): current_context = router.get_routing_context() router.navigate(path=\"/foo\", nav_context={\"prev_context\": current_context}) And then in the /foo route: from routing import router class FooForm(FooFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context self.init_components(**properties) def cancel_button_click(self, **event_args): prev_context = self.routing_context.nav_context.get(\"prev_context\") if prev_context is not None: router.navigate(prev_context) else: # no nav-context - the user navigated directly to the form by changing the url router.navigate(path=\"/\")","title":"Use of nav_context"},{"location":"navigating/blocking-navigation/","text":"Blocking Navigation \u00b6 You may want to prevent the user from navigating away from a page, if say, they are editing a form. from routing.router import RoutingContext, navigate class EditForm(EditFormTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.routing_context = routing_context self.routing_context.register_blocker(self.prevent_navigation) self.init_components(**properties) def prevent_navigation(self, **event_args): c = confirm(\"Are you sure you want to leave this page? Your changes will be lost.\") return not c def save_button_click(self, **event_args): self.routing_context.unregister_blocker(self.prevent_navigation) navigate(path=\"/dashboard\") Note When you register a blocker, if a user navigates to another website, the browser dialog asking if they want to leave the current page will be shown. Alternatively, you can use the NavigationBlocker context manager. from routing.router import NavigationBlocker class Form(FormTemplate): def __init__(self, **properties): self.init_components(**properties) def run_important_alert(self, **event_args): with NavigationBlocker(warn_before_unload=True): alert(\"Important Alert\", dismissible=False) The above navigation blocker will prevent the user navigating away from the page while the alert is open. warn_before_unload will show the browser dialog asking if the user wants to leave the page, if the user navigates to a new website. By default this is False .","title":"Blocking Navigation"},{"location":"navigating/blocking-navigation/#blocking-navigation","text":"You may want to prevent the user from navigating away from a page, if say, they are editing a form. from routing.router import RoutingContext, navigate class EditForm(EditFormTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.routing_context = routing_context self.routing_context.register_blocker(self.prevent_navigation) self.init_components(**properties) def prevent_navigation(self, **event_args): c = confirm(\"Are you sure you want to leave this page? Your changes will be lost.\") return not c def save_button_click(self, **event_args): self.routing_context.unregister_blocker(self.prevent_navigation) navigate(path=\"/dashboard\") Note When you register a blocker, if a user navigates to another website, the browser dialog asking if they want to leave the current page will be shown. Alternatively, you can use the NavigationBlocker context manager. from routing.router import NavigationBlocker class Form(FormTemplate): def __init__(self, **properties): self.init_components(**properties) def run_important_alert(self, **event_args): with NavigationBlocker(warn_before_unload=True): alert(\"Important Alert\", dismissible=False) The above navigation blocker will prevent the user navigating away from the page while the alert is open. warn_before_unload will show the browser dialog asking if the user wants to leave the page, if the user navigates to a new website. By default this is False .","title":"Blocking Navigation"},{"location":"navigating/navigation-components/","text":"Navigation Components \u00b6 A Navigation Component is useful over a Button with a click handler because it supports ctr/cmd clicking a route to open in a new tab, and should provide the correct href value for the browser. The routing library provides two Navigation Components: NavLink Anchor Navigation Components by default are subclasses of the Anvil.Link component. But this can be customized. See Themes for details. NavLink \u00b6 The NavLink component is a link that you will likely use in your main layout's sidebar. The routing library will set the active property on the NavLink to True when the NavLink's properties match the current routing context. If you are using the default NavLink component, then active means it will set it's role property to active . If the NavLink component is not the default, then how the active property behaves is determined by the Base class of the NavLink component. Navigation Attributes \u00b6 path The path to navigate to. e.g. /articles/123 or /articles or /articles/:id . The path can be relative ./ . If not set then the path will be the current path. params The params for the path. e.g. {\"id\": 123} query The query parameters to navigate to. e.g. {\"tab\": \"income\"} form_properties The form properties to pass to the form when it is opened. nav_context The nav context to for this navigation. hash The hash to navigate to. Tip If you want to set params or query in the designer, you can use the data binding feature of the designer. Active State \u00b6 active The active state of the NavLink. You probably don't want to set this. The routing library will set it to True when the NavLink's properties match the current routing context. exact_path If True then the path must match exactly. By default this is False . Which means a NavLink with a path of /articles will match the path /articles , /articles/123 and /articles/123/456 . exact_query If True then the query must inclusively match the current routing context's query. By default this is False . exact_hash If True then the hash must match exactly. By default this is False . You can set most properties in code or in the designer. In the designer, it is recommended to set query properties by using data bindings. Anchor \u00b6 Anchor is a link that you can use inline, or use as a container for other components. Unlike the NavLink, the Anchor component has no active property.","title":"Navigation Components"},{"location":"navigating/navigation-components/#navigation-components","text":"A Navigation Component is useful over a Button with a click handler because it supports ctr/cmd clicking a route to open in a new tab, and should provide the correct href value for the browser. The routing library provides two Navigation Components: NavLink Anchor Navigation Components by default are subclasses of the Anvil.Link component. But this can be customized. See Themes for details.","title":"Navigation Components"},{"location":"navigating/navigation-components/#navlink","text":"The NavLink component is a link that you will likely use in your main layout's sidebar. The routing library will set the active property on the NavLink to True when the NavLink's properties match the current routing context. If you are using the default NavLink component, then active means it will set it's role property to active . If the NavLink component is not the default, then how the active property behaves is determined by the Base class of the NavLink component.","title":"NavLink"},{"location":"navigating/navigation-components/#navigation-attributes","text":"path The path to navigate to. e.g. /articles/123 or /articles or /articles/:id . The path can be relative ./ . If not set then the path will be the current path. params The params for the path. e.g. {\"id\": 123} query The query parameters to navigate to. e.g. {\"tab\": \"income\"} form_properties The form properties to pass to the form when it is opened. nav_context The nav context to for this navigation. hash The hash to navigate to. Tip If you want to set params or query in the designer, you can use the data binding feature of the designer.","title":"Navigation Attributes"},{"location":"navigating/navigation-components/#active-state","text":"active The active state of the NavLink. You probably don't want to set this. The routing library will set it to True when the NavLink's properties match the current routing context. exact_path If True then the path must match exactly. By default this is False . Which means a NavLink with a path of /articles will match the path /articles , /articles/123 and /articles/123/456 . exact_query If True then the query must inclusively match the current routing context's query. By default this is False . exact_hash If True then the hash must match exactly. By default this is False . You can set most properties in code or in the designer. In the designer, it is recommended to set query properties by using data bindings.","title":"Active State"},{"location":"navigating/navigation-components/#anchor","text":"Anchor is a link that you can use inline, or use as a container for other components. Unlike the NavLink, the Anchor component has no active property.","title":"Anchor"},{"location":"routes/","text":"Route Class \u00b6 The Route class is used to define routes for your app. When a user navigates to a path, the router will look for a matching route. The router will call anvil.open_form on the matching route's form. # routes.py from routing.router import Route class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" class AboutRoute(Route): path = \"/about\" form = \"Pages.About\" class ContactRoute(Route): path = \"/contact\" form = \"Pages.Contact\" The above code can use the Route.create() method for convenience: # routes.py from routing.router import Route IndexRoute = Route.create(path=\"/\", form=\"Pages.Index\") AboutRoute = Route.create(path=\"/about\", form=\"Pages.About\") ContactRoute = Route.create(path=\"/contact\", form=\"Pages.Contact\") Route Attributes \u00b6 path The path to navigate to. e.g. / , /articles or /articles/:id . form The form to open when the route is matched. e.g. Pages.Index . error_form (optional) The form to open when an error occurs. e.g. Pages.Error . not_found_form (optional) The form to open when the route is not found. e.g. Pages.NotFound . pending_form (optional) The form to open when the data is loading. e.g. Pages.Loading . pending_delay=1 The delay before showing the pending form when the data is loading. pending_min=0.5 The minimum time to show the pending form when the data is loading. cache_data=False Whether to cache data. By default this is False . gc_time=30*60 The time in seconds that determines when data is released from the cache for garbage collection. By default this is 30 minutes. When data is released from the cache, any cached forms with the same path and cache_deps will also be released. server_fn (optional str) The server function to call when the route is matched. e.g. \"get_article\" . This server function will be called with the same keyword arguments as the route's load_data method. Note this is optional and equivalent to defining a load_data method the calls the same server function. server_silent=False If True then the server function will be called using anvil.server.call_s . By default this is False . Route Methods \u00b6 before_load Called before the route is matched. This method can raise a Redirect exception to redirect to a different route. By default this returns None . parse_query should return a dictionary of query parameters. By default this returns the original query parameters. parse_params should return a dictionary of path parameters. By default this returns the original path parameters. meta should return a dictionary with the title and description of the page. This will be used to update the meta tags and the title of the page. By default this returns the original title and description. load_data Called when the route is matched. The return value will be available in the data property of the RoutingContext instance. By default this returns None . load_form This method is called with two arguments. The first argument is a form name (e.g. \"Pages.Index\" ) or, if you are using cached forms, the cached form instance. The second argument is the RoutingContext instance. By default this calls anvil.open_form on the form. cache_deps Caching is determined by the path and the return value of the cache_deps method. The default implementation returns the query dictionary. That is, a route with the same path and query will be considered to be the same route. And routes with different query will be considered to be different routes. Not Found Form \u00b6 There are two ways a route can be not found. The first is when the user navigates to a path that does not match any routes. The second is when a user raises a NotFound exception in a route's before_load or load_data method. Not Found Route \u00b6 By definition, if there is not matching route, the router has no route to navigate to. If you want to handle this case, you can define a not found route. from routing.router import Route class NotFoundRoute(Route): form = \"Pages.NotFound\" default_not_found = True The NotFoundRoute will be used when the user navigates to a path that does not match any routes. The path attribute should not be set, since this will be determined based on the path the user navigates to. If no default_not_found attribute is set, then the router will raise a NotFound exception, which will be caught by Anvil's exception handler. Raising a NotFound Exception \u00b6 If you raise a NotFound exception in a route's before_load or load_data method, the router will call the route's load_form method with the route's not found form. from routing.router import Route class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" not_found_form = \"Pages.ArticleNotFound\" def load_data(self, **loader_args): id = loader_args[\"params\"][\"id\"] article = app_tables.articles.get(id=id) if article is None: raise NotFound(f\"No article with id {id}\") return article If a route raises a NotFound exception and there is no not_found_form attribute, the router will raise the exception, which will be caught by Anvil's exception handler. Error Form \u00b6 When a route throws an exception, the router will call anvil.open_form on the matching route's error form. If no error form is defined, the error will be caught by Anvil's exception handler. from routing.router import Route # Either define the error form globally Route.error_form = \"Pages.Error\" # or define the error form per route class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" error_form = \"Pages.Error\" # Pages.Error import anvil class Error(ErrorTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.init_components(**properties) self.routing_context = routing_context self.label.text = ( f\"Error when navigating to {routing_context.path!r}, got {routing_context.error!r}\" ) def form_show(self, **event_args): if anvil.app.environment.name.startswith(\"Debug\"): raise self.routing_context.error Ordering Routes \u00b6 The router will try to match routes in the order they are defined. from routing.router import Route class AuthorsRoute(Route): path = \"/authors\" form = \"Pages.Authors\" class NewAuthorRoute(Route): path = \"/authors/new\" form = \"Pages.NewAuthor\" class AuthorRoute(Route): path = \"/authors/:id\" form = \"Pages.Author\" In the above example, it's important that the NewAuthorRoute comes before the AuthorRoute in the list of routes. This is because /authors/new is a valid path for the AuthorRoute , so the router would successfully match the route and open the form. Server Routes \u00b6 When a user navigates to a url directly, the router will match routes on the server. When you import your routes in server code, the router will automatically create a server route for each route. # ServerRoutes.py from . import routes Under the hood this will look something like: # ServerRoutes.py from . import routes # pseudo code - for illustration only for route in Routes.__subclasses__(): if route.path is None: continue @anvil.server.route(route.path) def server_route(**params): ... # return a response object that will open the form on the client","title":"Route Class"},{"location":"routes/#route-class","text":"The Route class is used to define routes for your app. When a user navigates to a path, the router will look for a matching route. The router will call anvil.open_form on the matching route's form. # routes.py from routing.router import Route class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" class AboutRoute(Route): path = \"/about\" form = \"Pages.About\" class ContactRoute(Route): path = \"/contact\" form = \"Pages.Contact\" The above code can use the Route.create() method for convenience: # routes.py from routing.router import Route IndexRoute = Route.create(path=\"/\", form=\"Pages.Index\") AboutRoute = Route.create(path=\"/about\", form=\"Pages.About\") ContactRoute = Route.create(path=\"/contact\", form=\"Pages.Contact\")","title":"Route Class"},{"location":"routes/#route-attributes","text":"path The path to navigate to. e.g. / , /articles or /articles/:id . form The form to open when the route is matched. e.g. Pages.Index . error_form (optional) The form to open when an error occurs. e.g. Pages.Error . not_found_form (optional) The form to open when the route is not found. e.g. Pages.NotFound . pending_form (optional) The form to open when the data is loading. e.g. Pages.Loading . pending_delay=1 The delay before showing the pending form when the data is loading. pending_min=0.5 The minimum time to show the pending form when the data is loading. cache_data=False Whether to cache data. By default this is False . gc_time=30*60 The time in seconds that determines when data is released from the cache for garbage collection. By default this is 30 minutes. When data is released from the cache, any cached forms with the same path and cache_deps will also be released. server_fn (optional str) The server function to call when the route is matched. e.g. \"get_article\" . This server function will be called with the same keyword arguments as the route's load_data method. Note this is optional and equivalent to defining a load_data method the calls the same server function. server_silent=False If True then the server function will be called using anvil.server.call_s . By default this is False .","title":"Route Attributes"},{"location":"routes/#route-methods","text":"before_load Called before the route is matched. This method can raise a Redirect exception to redirect to a different route. By default this returns None . parse_query should return a dictionary of query parameters. By default this returns the original query parameters. parse_params should return a dictionary of path parameters. By default this returns the original path parameters. meta should return a dictionary with the title and description of the page. This will be used to update the meta tags and the title of the page. By default this returns the original title and description. load_data Called when the route is matched. The return value will be available in the data property of the RoutingContext instance. By default this returns None . load_form This method is called with two arguments. The first argument is a form name (e.g. \"Pages.Index\" ) or, if you are using cached forms, the cached form instance. The second argument is the RoutingContext instance. By default this calls anvil.open_form on the form. cache_deps Caching is determined by the path and the return value of the cache_deps method. The default implementation returns the query dictionary. That is, a route with the same path and query will be considered to be the same route. And routes with different query will be considered to be different routes.","title":"Route Methods"},{"location":"routes/#not-found-form","text":"There are two ways a route can be not found. The first is when the user navigates to a path that does not match any routes. The second is when a user raises a NotFound exception in a route's before_load or load_data method.","title":"Not Found Form"},{"location":"routes/#not-found-route","text":"By definition, if there is not matching route, the router has no route to navigate to. If you want to handle this case, you can define a not found route. from routing.router import Route class NotFoundRoute(Route): form = \"Pages.NotFound\" default_not_found = True The NotFoundRoute will be used when the user navigates to a path that does not match any routes. The path attribute should not be set, since this will be determined based on the path the user navigates to. If no default_not_found attribute is set, then the router will raise a NotFound exception, which will be caught by Anvil's exception handler.","title":"Not Found Route"},{"location":"routes/#raising-a-notfound-exception","text":"If you raise a NotFound exception in a route's before_load or load_data method, the router will call the route's load_form method with the route's not found form. from routing.router import Route class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" not_found_form = \"Pages.ArticleNotFound\" def load_data(self, **loader_args): id = loader_args[\"params\"][\"id\"] article = app_tables.articles.get(id=id) if article is None: raise NotFound(f\"No article with id {id}\") return article If a route raises a NotFound exception and there is no not_found_form attribute, the router will raise the exception, which will be caught by Anvil's exception handler.","title":"Raising a NotFound Exception"},{"location":"routes/#error-form","text":"When a route throws an exception, the router will call anvil.open_form on the matching route's error form. If no error form is defined, the error will be caught by Anvil's exception handler. from routing.router import Route # Either define the error form globally Route.error_form = \"Pages.Error\" # or define the error form per route class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" error_form = \"Pages.Error\" # Pages.Error import anvil class Error(ErrorTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.init_components(**properties) self.routing_context = routing_context self.label.text = ( f\"Error when navigating to {routing_context.path!r}, got {routing_context.error!r}\" ) def form_show(self, **event_args): if anvil.app.environment.name.startswith(\"Debug\"): raise self.routing_context.error","title":"Error Form"},{"location":"routes/#ordering-routes","text":"The router will try to match routes in the order they are defined. from routing.router import Route class AuthorsRoute(Route): path = \"/authors\" form = \"Pages.Authors\" class NewAuthorRoute(Route): path = \"/authors/new\" form = \"Pages.NewAuthor\" class AuthorRoute(Route): path = \"/authors/:id\" form = \"Pages.Author\" In the above example, it's important that the NewAuthorRoute comes before the AuthorRoute in the list of routes. This is because /authors/new is a valid path for the AuthorRoute , so the router would successfully match the route and open the form.","title":"Ordering Routes"},{"location":"routes/#server-routes","text":"When a user navigates to a url directly, the router will match routes on the server. When you import your routes in server code, the router will automatically create a server route for each route. # ServerRoutes.py from . import routes Under the hood this will look something like: # ServerRoutes.py from . import routes # pseudo code - for illustration only for route in Routes.__subclasses__(): if route.path is None: continue @anvil.server.route(route.path) def server_route(**params): ... # return a response object that will open the form on the client","title":"Server Routes"},{"location":"routes/forms/","text":"Forms \u00b6 The Route.load_form method is called when the route is matched. The default implementation will call anvil.open_form on the matching route's form. class Route: def load_form(self, form, routing_context): return anvil.open_form( form, routing_context=routing_context, **routing_context.form_properties ) This method will be called with the form attribute (e.g. \"Pages.Index\" ) or, if you are using cached forms, the cached form instance. open_form alternative \u00b6 If you are using traditional routing in your anvil app, you may have a template with a content_panel , and during navigation you clear the content panel and then add the new form to the panel. If you want to use this style of routing the routing library provides a TemplateWithContainerRoute class. This class overrides the load_form method. from routing.router import TemplateWithContainerRoute as BaseRoute BaseRoute.template = \"MainTemplate\" class IndexRoute(BaseRoute): path = \"/\" form = \"Pages.Index\" In this case, the load_form method will call anvil.open_form on the template form (if it is not already the current open form). It will then instantiate the form clear the content_panel of the template add add the form to the panel. If you are not using something other then content_panel , you can set the template_container attribute to the container name. You can also set the template_container_properties attribute to a dictionary of container properties. This is useful if you want to set the full_width_row attribute. from routing.router import TemplateWithContainerRoute as BaseRoute BaseRoute.template = \"MainTemplate\" BaseRoute.template_container = \"content_panel\" BaseRoute.template_container_properties = {\"full_width_row\": True} class IndexRoute(BaseRoute): path = \"/\" form = \"Pages.Index\"","title":"Forms"},{"location":"routes/forms/#forms","text":"The Route.load_form method is called when the route is matched. The default implementation will call anvil.open_form on the matching route's form. class Route: def load_form(self, form, routing_context): return anvil.open_form( form, routing_context=routing_context, **routing_context.form_properties ) This method will be called with the form attribute (e.g. \"Pages.Index\" ) or, if you are using cached forms, the cached form instance.","title":"Forms"},{"location":"routes/forms/#open_form-alternative","text":"If you are using traditional routing in your anvil app, you may have a template with a content_panel , and during navigation you clear the content panel and then add the new form to the panel. If you want to use this style of routing the routing library provides a TemplateWithContainerRoute class. This class overrides the load_form method. from routing.router import TemplateWithContainerRoute as BaseRoute BaseRoute.template = \"MainTemplate\" class IndexRoute(BaseRoute): path = \"/\" form = \"Pages.Index\" In this case, the load_form method will call anvil.open_form on the template form (if it is not already the current open form). It will then instantiate the form clear the content_panel of the template add add the form to the panel. If you are not using something other then content_panel , you can set the template_container attribute to the container name. You can also set the template_container_properties attribute to a dictionary of container properties. This is useful if you want to set the full_width_row attribute. from routing.router import TemplateWithContainerRoute as BaseRoute BaseRoute.template = \"MainTemplate\" BaseRoute.template_container = \"content_panel\" BaseRoute.template_container_properties = {\"full_width_row\": True} class IndexRoute(BaseRoute): path = \"/\" form = \"Pages.Index\"","title":"open_form alternative"},{"location":"routes/params/","text":"Params \u00b6 The path may contain one or more path parameters, denoted by the : character, e.g. /authors/:id . from routing.router import Route class AuthorRoute(Route): path = \"/authors/:id\" form = \"Pages.Author\" When a user navigates to /authors/123 , the routing context will include the path params {\"id\": 123} . from ._anvil_designer import AuthorTemplate from routing.router import RoutingContext class Author(AuthorTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.routing_context = routing_context self.author = anvil.server.call(\"get_author\", routing_context.params.get(\"id\")) self.init_components(**properties) Parsing Params \u00b6 By default, the params are considered json-able. e.g. if the path is \"/articles/123\" then the 123 is an integer after calling json.loads . If you want to parse the params into a different type, you can use the parse_params method. class AuthorRoute(Route): path = \"/authors/:id\" form = \"Pages.Author\" def parse_params(self, params): return {\"id\": str(params[\"id\"])} Note If you have numbers in your params, but these should actually be strings, you can convert these to str in your parse_params method. Navigating with Params \u00b6 You can navigate to a route with params by passing the params option to the navigate function. from routing.router import navigate ... def button_click(self, **event_args): navigate(path=\"/authors/:id\", params={\"id\": 123}) Or equivalently with routing NavLink or Anchor components. from ._anvil_designer import RowTemplateTemplate from routing.router import NavLink class RowTemplate(RowTemplateTemplate): def __init__(self, **properties): self.init_components(**properties) self.add_component( NavLink( text=f\"Author {self.item['name']}\", path=\"/authors/:id\", params={\"id\": self.item[\"id\"]}, ) ) Other equivalent ways to navigate include: from routing.router import navigate navigate(path=\"/authors/123\") # the params will still become {\"id\": 123} from routing.router import navigate from ...routes import AuthorRoute navigate(path=AuthorRoute.path, params={\"id\": 123})","title":"Params"},{"location":"routes/params/#params","text":"The path may contain one or more path parameters, denoted by the : character, e.g. /authors/:id . from routing.router import Route class AuthorRoute(Route): path = \"/authors/:id\" form = \"Pages.Author\" When a user navigates to /authors/123 , the routing context will include the path params {\"id\": 123} . from ._anvil_designer import AuthorTemplate from routing.router import RoutingContext class Author(AuthorTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.routing_context = routing_context self.author = anvil.server.call(\"get_author\", routing_context.params.get(\"id\")) self.init_components(**properties)","title":"Params"},{"location":"routes/params/#parsing-params","text":"By default, the params are considered json-able. e.g. if the path is \"/articles/123\" then the 123 is an integer after calling json.loads . If you want to parse the params into a different type, you can use the parse_params method. class AuthorRoute(Route): path = \"/authors/:id\" form = \"Pages.Author\" def parse_params(self, params): return {\"id\": str(params[\"id\"])} Note If you have numbers in your params, but these should actually be strings, you can convert these to str in your parse_params method.","title":"Parsing Params"},{"location":"routes/params/#navigating-with-params","text":"You can navigate to a route with params by passing the params option to the navigate function. from routing.router import navigate ... def button_click(self, **event_args): navigate(path=\"/authors/:id\", params={\"id\": 123}) Or equivalently with routing NavLink or Anchor components. from ._anvil_designer import RowTemplateTemplate from routing.router import NavLink class RowTemplate(RowTemplateTemplate): def __init__(self, **properties): self.init_components(**properties) self.add_component( NavLink( text=f\"Author {self.item['name']}\", path=\"/authors/:id\", params={\"id\": self.item[\"id\"]}, ) ) Other equivalent ways to navigate include: from routing.router import navigate navigate(path=\"/authors/123\") # the params will still become {\"id\": 123} from routing.router import navigate from ...routes import AuthorRoute navigate(path=AuthorRoute.path, params={\"id\": 123})","title":"Navigating with Params"},{"location":"routes/query/","text":"Query \u00b6 Query parameters are encoded in a url following a ? , e.g. /dashboard?tab=sales&page=1 . Query parameters may be referred to by different names, e.g. search, search params, query params, etc. In this routing library we will refer to query as a dictionary of query parameters. And a query string will be the url encoded version of the query . The query is best used to encode the state of the page. For example, if you have a dashboard page with a tab component, you can use the query to encode the active tab. Navigating \u00b6 Let's say you have a dashboard page with a tab component. The tab component has 2 tabs, income and expenses. from ._anvil_designer import DashboardTemplate from routing.router import navigate, RoutingContext class Dashboard(DashboardTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.init_components(**properties) self.routing_context = routing_context routing_context.add_event_handler(\"query_changed\", self.on_query_change) routing_context.raise_init_events() # raises the query_changed event def on_query_change(self, **event_args): query = self.routing_context.query self.tab_1.value = query.get(\"tab\", \"income\") def tab_changed(self, **event_args): tab_value = self.tab_1.value navigate(query={\"tab\": tab_value}) Note that in the tab_changed event handler, we are navigating to the same path, and so, we don't need to include the path in the navigate call. If we want to be explicit, we can use path=\"./\" or path=\"/dashboard\" . By default, if the query parameters change, a new instance of the form will be loaded (even if cache_form is set to True ). See cache_deps below for more details. When the query parameters change, we can listen for the query_changed event and update our page state accordingly. Parsing Query Parameters \u00b6 Since query parameters are encoded in the url, we may need to decode them. It's also generally a good idea to ignore unknown query parameters and provide sensible defaults if any are missing, or incorrect. This provides a better user experience. from routing.router import Route class DashboardRoute(Route): path = \"/dashboard\" form = \"Pages.Dashboard\" def parse_query(self, query): valid_tabs = [\"income\", \"expenses\"] tab = query.get(\"tab\", \"income\") if tab not in valid_tabs: tab = \"income\" return {\"tab\": tab} Using a query validator \u00b6 You can use a validator library. And if the validator has a parse method, it can be used as the parse_query attribute. from anvil_extras import zod as z class DashboardRoute(Route): path = \"/dashboard\" form = \"Pages.Dashboard\" parse_query = z.typed_dict({ \"tab\": z.enum([\"income\", \"expenses\"]).catch(\"income\") }) Query encoding \u00b6 The routing library can encode any json-able object as a query parameter. Where a query parameter is a str , int , float , bool or None this will be flat. e.g. ?foo=bar&baz=1&eggs=true will be decoded as {\"foo\": \"bar\", \"baz\": 1, \"eggs\": True} . Note If you have numbers in your query parameters, but these should actually be strings, you can convert these to str in your parse_query method. For nested, json-able objects, i.e. lists and dicts , the routing library will encode the object as a json string in the query string. e.g. foo=%5B1%2C+%22a%22%2C+true%5D' will be decoded as {\"foo\": [1, \"a\", true]} . Loading a new instance of a form \u00b6 By default the routing library will load a new instance of a form when the query parameters change. If you do NOT wish to load a new instance of a form when certain query parameters change, you can override the cache_deps method. This method should return a dict of dependencies, which determine when a form and its data should be loaded from cache . The return value from cache_deps should be json-able. from routing.router import Route class DashboardRoute(Route): path = \"/dashboard\" form = \"DashboardForm\" cache_form = True def cache_deps(self, **loader_args): # this form is cached uniquely by the `path` only - there are no `query` dependencies # i.e. if the `tab` changes, we keep the same instance of the form return None For more details on cache_deps see the data loading section.","title":"Query"},{"location":"routes/query/#query","text":"Query parameters are encoded in a url following a ? , e.g. /dashboard?tab=sales&page=1 . Query parameters may be referred to by different names, e.g. search, search params, query params, etc. In this routing library we will refer to query as a dictionary of query parameters. And a query string will be the url encoded version of the query . The query is best used to encode the state of the page. For example, if you have a dashboard page with a tab component, you can use the query to encode the active tab.","title":"Query"},{"location":"routes/query/#navigating","text":"Let's say you have a dashboard page with a tab component. The tab component has 2 tabs, income and expenses. from ._anvil_designer import DashboardTemplate from routing.router import navigate, RoutingContext class Dashboard(DashboardTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.init_components(**properties) self.routing_context = routing_context routing_context.add_event_handler(\"query_changed\", self.on_query_change) routing_context.raise_init_events() # raises the query_changed event def on_query_change(self, **event_args): query = self.routing_context.query self.tab_1.value = query.get(\"tab\", \"income\") def tab_changed(self, **event_args): tab_value = self.tab_1.value navigate(query={\"tab\": tab_value}) Note that in the tab_changed event handler, we are navigating to the same path, and so, we don't need to include the path in the navigate call. If we want to be explicit, we can use path=\"./\" or path=\"/dashboard\" . By default, if the query parameters change, a new instance of the form will be loaded (even if cache_form is set to True ). See cache_deps below for more details. When the query parameters change, we can listen for the query_changed event and update our page state accordingly.","title":"Navigating"},{"location":"routes/query/#parsing-query-parameters","text":"Since query parameters are encoded in the url, we may need to decode them. It's also generally a good idea to ignore unknown query parameters and provide sensible defaults if any are missing, or incorrect. This provides a better user experience. from routing.router import Route class DashboardRoute(Route): path = \"/dashboard\" form = \"Pages.Dashboard\" def parse_query(self, query): valid_tabs = [\"income\", \"expenses\"] tab = query.get(\"tab\", \"income\") if tab not in valid_tabs: tab = \"income\" return {\"tab\": tab}","title":"Parsing Query Parameters"},{"location":"routes/query/#using-a-query-validator","text":"You can use a validator library. And if the validator has a parse method, it can be used as the parse_query attribute. from anvil_extras import zod as z class DashboardRoute(Route): path = \"/dashboard\" form = \"Pages.Dashboard\" parse_query = z.typed_dict({ \"tab\": z.enum([\"income\", \"expenses\"]).catch(\"income\") })","title":"Using a query validator"},{"location":"routes/query/#query-encoding","text":"The routing library can encode any json-able object as a query parameter. Where a query parameter is a str , int , float , bool or None this will be flat. e.g. ?foo=bar&baz=1&eggs=true will be decoded as {\"foo\": \"bar\", \"baz\": 1, \"eggs\": True} . Note If you have numbers in your query parameters, but these should actually be strings, you can convert these to str in your parse_query method. For nested, json-able objects, i.e. lists and dicts , the routing library will encode the object as a json string in the query string. e.g. foo=%5B1%2C+%22a%22%2C+true%5D' will be decoded as {\"foo\": [1, \"a\", true]} .","title":"Query encoding"},{"location":"routes/query/#loading-a-new-instance-of-a-form","text":"By default the routing library will load a new instance of a form when the query parameters change. If you do NOT wish to load a new instance of a form when certain query parameters change, you can override the cache_deps method. This method should return a dict of dependencies, which determine when a form and its data should be loaded from cache . The return value from cache_deps should be json-able. from routing.router import Route class DashboardRoute(Route): path = \"/dashboard\" form = \"DashboardForm\" cache_form = True def cache_deps(self, **loader_args): # this form is cached uniquely by the `path` only - there are no `query` dependencies # i.e. if the `tab` changes, we keep the same instance of the form return None For more details on cache_deps see the data loading section.","title":"Loading a new instance of a form"},{"location":"routes/redirecting/","text":"Redirecting \u00b6 You can redirect to a different route by raising a Redirect exception in a route's before_load method. from routing.router import Route, Redirect class IndexRoute(Route): path = \"/\" def before_load(self, **loader_args): raise Redirect(path=\"/dashboard\") In the above example, the user will be redirected to the /dashboard route when they navigate to your app. A common use case for redirecting is to ensure that a user is logged in before navigating to a route. from routing.router import Route, Redirect import anvil.users class IndexRoute(Route): path = \"/\" def before_load(self, **loader_args): if anvil.users.get_user(): raise Redirect(path=\"/dashboard\") else: raise Redirect(path=\"/login\") class EnsureUserMixin: def before_load(self, **loader_args): if not anvil.users.get_user(): # Note this will make a server call # so you may want to cache the call to anvil.users.get_user() raise Redirect(path=\"/login\") class DashboardRoute(EnsureUserMixin, Route): path = \"/dashboard\" form = \"Pages.Dashboard\" Note A determined user will be able to bypass the redirect by opening the form directly. Always ensure you check the user is logged in on the server before sending sensitive data to the client.","title":"Redirecting"},{"location":"routes/redirecting/#redirecting","text":"You can redirect to a different route by raising a Redirect exception in a route's before_load method. from routing.router import Route, Redirect class IndexRoute(Route): path = \"/\" def before_load(self, **loader_args): raise Redirect(path=\"/dashboard\") In the above example, the user will be redirected to the /dashboard route when they navigate to your app. A common use case for redirecting is to ensure that a user is logged in before navigating to a route. from routing.router import Route, Redirect import anvil.users class IndexRoute(Route): path = \"/\" def before_load(self, **loader_args): if anvil.users.get_user(): raise Redirect(path=\"/dashboard\") else: raise Redirect(path=\"/login\") class EnsureUserMixin: def before_load(self, **loader_args): if not anvil.users.get_user(): # Note this will make a server call # so you may want to cache the call to anvil.users.get_user() raise Redirect(path=\"/login\") class DashboardRoute(EnsureUserMixin, Route): path = \"/dashboard\" form = \"Pages.Dashboard\" Note A determined user will be able to bypass the redirect by opening the form directly. Always ensure you check the user is logged in on the server before sending sensitive data to the client.","title":"Redirecting"},{"location":"routing-context/","text":"Routing Context \u00b6 A RoutingContext instance is passed to a form when it is instantiated. It provides information about the current route and the current navigation context. from ._anvil_designer import IndexTemplate from routing.router import RoutingContext class IndexTemplate(IndexTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.routing_context = routing_context self.init_components(**properties) Autocompletion Adding the RoutingContext type definition will allow anvil to show autocompletion for the routing_context property. Properties \u00b6 path The path for the current route. params The parameters for the current route. query The query parameters for the current route. hash The hash for the current route. deps The dependencies dict returned by the cache_deps method. nav_context The navigation context for the current route. This is a dict and can be set by passing a nav_context argument to the navigate method. (Or equivalently by setting the nav_context attribute on a NavLink / Anchor component). form_properties The form properties for the current route. This is a dict and can be set by passing a form_properties argument to the navigate method. (Or equivalently by setting the form_properties attribute on the NavLink / Anchor component). Note the form_properties are passed as keyword arguments when instantiating a form. For more details see the Navigation section. error The error that occurred when loading the form or loading the data. This is particularly useful when displaying error messages in your error form. data The data for the current route. This is the value returned from the load_data method. Events \u00b6 The RoutingContext instance will emit events when the route changes. data_loading Emitted when the data is loading. data_loaded Emitted when the data has been loaded, or when the data has an error. To determine if the data is loaded successfully, check the error property is None . data_error Emitted when the data has an error. query_changed Emitted when the query parameters change. hash_changed Emitted when the hash changes. Methods \u00b6 invalidate(exact=False) Invalidates any cached data or forms for this routing context. If exact is True , then the path and deps must match exactly. By default this is False . If False then any path or deps that are a subset of path and deps arguments will be invalidated. refetch() Invalidates the data for this routing context (with exact=True) and then loads the data again. raise_init_events() Raises the data_loaded , data_loading , data_error , query_changed and hash_changed events. This event is useful during instantiation of the form. First setup your event handlers, then call raise_init_events() .","title":"Routing Context"},{"location":"routing-context/#routing-context","text":"A RoutingContext instance is passed to a form when it is instantiated. It provides information about the current route and the current navigation context. from ._anvil_designer import IndexTemplate from routing.router import RoutingContext class IndexTemplate(IndexTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.routing_context = routing_context self.init_components(**properties) Autocompletion Adding the RoutingContext type definition will allow anvil to show autocompletion for the routing_context property.","title":"Routing Context"},{"location":"routing-context/#properties","text":"path The path for the current route. params The parameters for the current route. query The query parameters for the current route. hash The hash for the current route. deps The dependencies dict returned by the cache_deps method. nav_context The navigation context for the current route. This is a dict and can be set by passing a nav_context argument to the navigate method. (Or equivalently by setting the nav_context attribute on a NavLink / Anchor component). form_properties The form properties for the current route. This is a dict and can be set by passing a form_properties argument to the navigate method. (Or equivalently by setting the form_properties attribute on the NavLink / Anchor component). Note the form_properties are passed as keyword arguments when instantiating a form. For more details see the Navigation section. error The error that occurred when loading the form or loading the data. This is particularly useful when displaying error messages in your error form. data The data for the current route. This is the value returned from the load_data method.","title":"Properties"},{"location":"routing-context/#events","text":"The RoutingContext instance will emit events when the route changes. data_loading Emitted when the data is loading. data_loaded Emitted when the data has been loaded, or when the data has an error. To determine if the data is loaded successfully, check the error property is None . data_error Emitted when the data has an error. query_changed Emitted when the query parameters change. hash_changed Emitted when the hash changes.","title":"Events"},{"location":"routing-context/#methods","text":"invalidate(exact=False) Invalidates any cached data or forms for this routing context. If exact is True , then the path and deps must match exactly. By default this is False . If False then any path or deps that are a subset of path and deps arguments will be invalidated. refetch() Invalidates the data for this routing context (with exact=True) and then loads the data again. raise_init_events() Raises the data_loaded , data_loading , data_error , query_changed and hash_changed events. This event is useful during instantiation of the form. First setup your event handlers, then call raise_init_events() .","title":"Methods"},{"location":"theme/","text":"Theme \u00b6 If you are writing a custom theme for your anvil app, you may want to use your own components for the NavLink and Anchor base classes. The default implementation for the NavLink and Anchor base classes are: import anvil class NavLinkBase(anvil.Link): def __init__(self, active=None, **properties): self._props = properties super().__init__(**properties) @property def active(self): return self._props.get(\"active\") @active.setter def active(self, value): self._props[\"active\"] = value self.role = \"active\" if value else None class AnchorBase(anvil.Link): pass TODO - not yet supported APIs To tell the routing library to use your own base classes, you can call the anvil's set_config method in the preload module. # preload module from anvil import set_config from ...MyNavLink import MyNavLink from ...MyAnchor import MyAnchor set_config(nav_link=MyNavLink, anchor=MyAnchor) Existing Themes \u00b6 Mantine M3 TODO Note If you are using multiple themes that set the NavLink and Anchor base classes, then the last theme to set the base classes will be used.","title":"Theme"},{"location":"theme/#theme","text":"If you are writing a custom theme for your anvil app, you may want to use your own components for the NavLink and Anchor base classes. The default implementation for the NavLink and Anchor base classes are: import anvil class NavLinkBase(anvil.Link): def __init__(self, active=None, **properties): self._props = properties super().__init__(**properties) @property def active(self): return self._props.get(\"active\") @active.setter def active(self, value): self._props[\"active\"] = value self.role = \"active\" if value else None class AnchorBase(anvil.Link): pass TODO - not yet supported APIs To tell the routing library to use your own base classes, you can call the anvil's set_config method in the preload module. # preload module from anvil import set_config from ...MyNavLink import MyNavLink from ...MyAnchor import MyAnchor set_config(nav_link=MyNavLink, anchor=MyAnchor)","title":"Theme"},{"location":"theme/#existing-themes","text":"Mantine M3 TODO Note If you are using multiple themes that set the NavLink and Anchor base classes, then the last theme to set the base classes will be used.","title":"Existing Themes"}]}