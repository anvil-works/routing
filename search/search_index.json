{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 Routing lets you configure URL paths to allow your users to navigate to specific parts and states of your app directly through their browser's address bar. In general, this brings your app closer to a regular web page in terms of usage standards. For example, this can be useful for letting users bookmark specific parts of your app, or enabling usage of the back and forward buttons to navigate throughout your app. Routing Basics \u00b6 A route is an object with, among other attributes, a URL path, and a form to open when navigating to this route. As an app developer, you will need to define routes for your app. When the URL changes, the router will look for a matching route. The ultimate goal is to open the form associated with the given URL. The router will attempt to match routes in the order they are defined. When a route is found, the router will call the route's before_load method. - If the before_load method raises a Redirect , the router will navigate to the redirected URL. - If the before_load method returns a dictionary, its contents will be merged into the navigation context ( nav_context ) for the route. If the route has a load_data method, it will be called, and the return value will be available as the data property on the RoutingContext . Once the load_data method has been called, the router will call the route's load_form method. A routing_context will be passed to this method. By default, the load_form method will call anvil.open_form on the matching route's form, with routing_context passed as a keyword argument. Caching \u00b6 There are two types of caching: form caching and data caching. If a form is cached, instead of creating a new instance, the router will call the route's load_form method with the cached form instance. If data is cached, the router will only call the load_data method if the data is stale. See the Caching section for more details. Server vs Client Routing \u00b6 Should the user open the app directly through a URL as their initial page request, the routing process will occur entirely on the server. Otherwise, if the user is navigating from within the app, the process occurs on the client.","title":"Overview"},{"location":"#overview","text":"Routing lets you configure URL paths to allow your users to navigate to specific parts and states of your app directly through their browser's address bar. In general, this brings your app closer to a regular web page in terms of usage standards. For example, this can be useful for letting users bookmark specific parts of your app, or enabling usage of the back and forward buttons to navigate throughout your app.","title":"Overview"},{"location":"#routing-basics","text":"A route is an object with, among other attributes, a URL path, and a form to open when navigating to this route. As an app developer, you will need to define routes for your app. When the URL changes, the router will look for a matching route. The ultimate goal is to open the form associated with the given URL. The router will attempt to match routes in the order they are defined. When a route is found, the router will call the route's before_load method. - If the before_load method raises a Redirect , the router will navigate to the redirected URL. - If the before_load method returns a dictionary, its contents will be merged into the navigation context ( nav_context ) for the route. If the route has a load_data method, it will be called, and the return value will be available as the data property on the RoutingContext . Once the load_data method has been called, the router will call the route's load_form method. A routing_context will be passed to this method. By default, the load_form method will call anvil.open_form on the matching route's form, with routing_context passed as a keyword argument.","title":"Routing Basics"},{"location":"#caching","text":"There are two types of caching: form caching and data caching. If a form is cached, instead of creating a new instance, the router will call the route's load_form method with the cached form instance. If data is cached, the router will only call the load_data method if the data is stale. See the Caching section for more details.","title":"Caching"},{"location":"#server-vs-client-routing","text":"Should the user open the app directly through a URL as their initial page request, the routing process will occur entirely on the server. Otherwise, if the user is navigating from within the app, the process occurs on the client.","title":"Server vs Client Routing"},{"location":"api-reference/","text":"API Reference \u00b6 The routing library provides the following functions, classes, and attributes. All attributes can be accessed from the routing.router module. Router Configuration \u00b6 When adding the routing library as a dependency, in the Anvil IDE, click the \"edit\" icon next to the routing library in the dependencies list. This will allow you to change the configuration options. Config Options: \u00b6 sitemap If False , disables the automatic /sitemap.txt route. Defaults to False . robots If False , disables the automatic /robots.txt route. Defaults to False . routes_module The module where your routes are defined (e.g. utils.routes ). Defaults to routes . routes_module \u00b6 If set, the router will automatically import this module for you, and you do not need to explicitly import your routes module in client or server code. This is the preferred approach for most projects. By default this is set to routes . If you do not set this option correctly, you must explicitly import your routes module in your startup and server code: # In a startup module, e.g. startup.py from . import routes # In a server module, e.g. ServerRoutes.py from . import routes Functions \u00b6 navigate(*, path=None, params=None, query=None, hash=None, replace=False, nav_context=None, form_properties=None) navigate(path, **kws) navigate(url, **kws) navigate(routing_context, **kws) Navigates to a new page. launch() Launches the routing library and navigates to the first route. Call this in your startup module. go(n=0) Navigates to the nth page in the history stack. back() Navigates back in the history stack. forward() Navigates forward in the history stack. reload(hard=False) Reloads the current page. If hard is True , the page will be reloaded from the server. If hard is False , the page will be removed from the cache and reloaded on the client. add_event_handler(event_name, handler) Adds an event handler for the given event name. The event handler should take a **event_args argument. The event_name can be one of the following: \"navigate\" : raised when the url changes. \"pending\" : raised when the navigation starts. \"idle\" : raised when the navigation is complete. remove_event_handler(event_name, handler) Removes an event handler for the given event name. get_routing_context() Returns the current routing context. use_data(context_or_path_or_url=None, *, path=None, params=None, query=None, hash=None) Loads and returns the data for the specified url/context (or for the specified path/params/query/hash). Returns the data (or raises if there is an error). If called with no arguments, uses the current navigation context. Can be useful for routes that share data. Or layouts that need access to the data for the current route. get_url() get_url(*, path=None, params=None, query=None, hash=None, full=False) get_url(path, **kws) get_url(routing_context, **kws) Gets the URL. If no keyword arguments are passed, the current URL will be returned. If full is True , the full URL will be returned (e.g., http://my-app.anvil.app/articles/123?foo=bar#hash ). If full is False , the URL will be relative to the base URL (e.g., /articles/123?foo=bar#hash ). debug_logging(enable=True) Enables or disables debug logging. clear_cache() Clears the cache of forms and data. invalidate(*, path=None, deps=None, exact=False) Invalidates any cached data and forms based on the path and deps. The exact argument determines whether to invalidate based on an exact match or a partial match. open_form(form, **form_properties) When migrating, you may be able to replace anvil.open_form with router.open_form . This will only work if you are not using params . alert(content, *args, dismissible=True, **kwargs) Shows an alert. If dismissible is True , the alert will be dismissed when the user navigates to a new page. To override Anvil's default alert, you can set the anvil.alert = router.alert . confirm(content, *args, dismissible=True, **kwargs) Shows a confirmation dialog. If dismissible is True , the dialog will be dismissed when the user navigates to a new page. To override Anvil's default alert, you can set the anvil.alert = router.alert . hooks.before_load(func) Decorator to register a method as a before_load hook for a Route. Hooks are called in the order they are defined on the class. Each hook receives a nav_context keyword argument (the context dict accumulated so far), which can be read and updated for composable navigation logic. from routing.router import Route, hooks, Redirect class AuthenticatedRoute(Route): # Style 1: Mutate nav_context directly @hooks.before_load def set_user(self, nav_context, **loader_args): nav_context[\"user\"] = get_current_user() # Style 2: Return a partial dict to be merged into nav_context @hooks.before_load def set_user_partial(self, nav_context, **loader_args): return {\"user\": get_current_user()} @hooks.before_load def check_permissions(self, nav_context, **loader_args): user = nav_context.get(\"user\") if not user or not user.has_permission(): raise Redirect(path=\"/login\") # Both styles are supported; the returned dictionary (if any) will be merged into nav_context after the hook runs. You may also attach hooks globally to all routes by assigning to the base class: @hooks.before_load def global_hook(self, nav_context, **loader_args): nav_context[\"feature_enabled\"] = True Route.global_hook = global_hook See the navigation documentation for advanced composition and usage patterns. Classes \u00b6 Route The base class for all routes. RoutingContext Provides information about the current route and navigation context. Passed to all forms instantiated by the routing library. sorted_routes A list of all registered routes, sorted in the order they will be matched. Useful for introspection, generating sitemaps, or custom navigation logic. Components \u00b6 NavLink.NavLink A link that you will likely use in your main layout's sidebar. Has an active property that is set when the NavLink's navigation properties match the current routing context. Anchor.Anchor A link that you can use inline or as a container for other components. Context Managers \u00b6 NavigationBlocker A context manager that will prevent the user from navigating away during the context. Exceptions \u00b6 Redirect Raise during a route's before_load method to redirect to a different route. NotFound Raised when a route is not found for a given path.","title":"API Reference"},{"location":"api-reference/#api-reference","text":"The routing library provides the following functions, classes, and attributes. All attributes can be accessed from the routing.router module.","title":"API Reference"},{"location":"api-reference/#router-configuration","text":"When adding the routing library as a dependency, in the Anvil IDE, click the \"edit\" icon next to the routing library in the dependencies list. This will allow you to change the configuration options.","title":"Router Configuration"},{"location":"api-reference/#config-options","text":"sitemap If False , disables the automatic /sitemap.txt route. Defaults to False . robots If False , disables the automatic /robots.txt route. Defaults to False . routes_module The module where your routes are defined (e.g. utils.routes ). Defaults to routes .","title":"Config Options:"},{"location":"api-reference/#routes_module","text":"If set, the router will automatically import this module for you, and you do not need to explicitly import your routes module in client or server code. This is the preferred approach for most projects. By default this is set to routes . If you do not set this option correctly, you must explicitly import your routes module in your startup and server code: # In a startup module, e.g. startup.py from . import routes # In a server module, e.g. ServerRoutes.py from . import routes","title":"routes_module"},{"location":"api-reference/#functions","text":"navigate(*, path=None, params=None, query=None, hash=None, replace=False, nav_context=None, form_properties=None) navigate(path, **kws) navigate(url, **kws) navigate(routing_context, **kws) Navigates to a new page. launch() Launches the routing library and navigates to the first route. Call this in your startup module. go(n=0) Navigates to the nth page in the history stack. back() Navigates back in the history stack. forward() Navigates forward in the history stack. reload(hard=False) Reloads the current page. If hard is True , the page will be reloaded from the server. If hard is False , the page will be removed from the cache and reloaded on the client. add_event_handler(event_name, handler) Adds an event handler for the given event name. The event handler should take a **event_args argument. The event_name can be one of the following: \"navigate\" : raised when the url changes. \"pending\" : raised when the navigation starts. \"idle\" : raised when the navigation is complete. remove_event_handler(event_name, handler) Removes an event handler for the given event name. get_routing_context() Returns the current routing context. use_data(context_or_path_or_url=None, *, path=None, params=None, query=None, hash=None) Loads and returns the data for the specified url/context (or for the specified path/params/query/hash). Returns the data (or raises if there is an error). If called with no arguments, uses the current navigation context. Can be useful for routes that share data. Or layouts that need access to the data for the current route. get_url() get_url(*, path=None, params=None, query=None, hash=None, full=False) get_url(path, **kws) get_url(routing_context, **kws) Gets the URL. If no keyword arguments are passed, the current URL will be returned. If full is True , the full URL will be returned (e.g., http://my-app.anvil.app/articles/123?foo=bar#hash ). If full is False , the URL will be relative to the base URL (e.g., /articles/123?foo=bar#hash ). debug_logging(enable=True) Enables or disables debug logging. clear_cache() Clears the cache of forms and data. invalidate(*, path=None, deps=None, exact=False) Invalidates any cached data and forms based on the path and deps. The exact argument determines whether to invalidate based on an exact match or a partial match. open_form(form, **form_properties) When migrating, you may be able to replace anvil.open_form with router.open_form . This will only work if you are not using params . alert(content, *args, dismissible=True, **kwargs) Shows an alert. If dismissible is True , the alert will be dismissed when the user navigates to a new page. To override Anvil's default alert, you can set the anvil.alert = router.alert . confirm(content, *args, dismissible=True, **kwargs) Shows a confirmation dialog. If dismissible is True , the dialog will be dismissed when the user navigates to a new page. To override Anvil's default alert, you can set the anvil.alert = router.alert . hooks.before_load(func) Decorator to register a method as a before_load hook for a Route. Hooks are called in the order they are defined on the class. Each hook receives a nav_context keyword argument (the context dict accumulated so far), which can be read and updated for composable navigation logic. from routing.router import Route, hooks, Redirect class AuthenticatedRoute(Route): # Style 1: Mutate nav_context directly @hooks.before_load def set_user(self, nav_context, **loader_args): nav_context[\"user\"] = get_current_user() # Style 2: Return a partial dict to be merged into nav_context @hooks.before_load def set_user_partial(self, nav_context, **loader_args): return {\"user\": get_current_user()} @hooks.before_load def check_permissions(self, nav_context, **loader_args): user = nav_context.get(\"user\") if not user or not user.has_permission(): raise Redirect(path=\"/login\") # Both styles are supported; the returned dictionary (if any) will be merged into nav_context after the hook runs. You may also attach hooks globally to all routes by assigning to the base class: @hooks.before_load def global_hook(self, nav_context, **loader_args): nav_context[\"feature_enabled\"] = True Route.global_hook = global_hook See the navigation documentation for advanced composition and usage patterns.","title":"Functions"},{"location":"api-reference/#classes","text":"Route The base class for all routes. RoutingContext Provides information about the current route and navigation context. Passed to all forms instantiated by the routing library. sorted_routes A list of all registered routes, sorted in the order they will be matched. Useful for introspection, generating sitemaps, or custom navigation logic.","title":"Classes"},{"location":"api-reference/#components","text":"NavLink.NavLink A link that you will likely use in your main layout's sidebar. Has an active property that is set when the NavLink's navigation properties match the current routing context. Anchor.Anchor A link that you can use inline or as a container for other components.","title":"Components"},{"location":"api-reference/#context-managers","text":"NavigationBlocker A context manager that will prevent the user from navigating away during the context.","title":"Context Managers"},{"location":"api-reference/#exceptions","text":"Redirect Raise during a route's before_load method to redirect to a different route. NotFound Raised when a route is not found for a given path.","title":"Exceptions"},{"location":"installation/","text":"Installation \u00b6 Third Party Dependency \u00b6 To use as a third party dependency, utilise the code 3PIDO5P3H4VPEMPL Clone from GitHub \u00b6 In the Anvil editor, click the Clone from GitHub button. Select Authentication \"Anonymous\" . Enter the URL for the routing library repository: https://github.com/anvil-works/routing . Click Clone App . This will clone the routing library into your Anvil account. Whenever changes are made to the GitHub repository, you can click Sync Git Remotes to update your clone.","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#third-party-dependency","text":"To use as a third party dependency, utilise the code 3PIDO5P3H4VPEMPL","title":"Third Party Dependency"},{"location":"installation/#clone-from-github","text":"In the Anvil editor, click the Clone from GitHub button. Select Authentication \"Anonymous\" . Enter the URL for the routing library repository: https://github.com/anvil-works/routing . Click Clone App . This will clone the routing library into your Anvil account. Whenever changes are made to the GitHub repository, you can click Sync Git Remotes to update your clone.","title":"Clone from GitHub"},{"location":"quick-start/","text":"Quick Start \u00b6 From a Clone \u00b6 Clone the following Anvil app: https://anvil.works/build#clone:34ZTMM7IQRTCMIAD=PPWCEPHZKQ3VYBIEF6T7GWOY From a New App \u00b6 Create a new app. Client Code Structure \u00b6 The client code structure should look like this: - Layouts (Package) - Main (Form - ensure you tick \"Use as layout\") - Pages (Package) - Index (Form choosing Layouts.Main as the layout) - About (Form choosing Layouts.Main as the layout) - Contact (Form choosing Layouts.Main as the layout) - routes (Module) - startup (Module) Startup Module \u00b6 # startup.py from routing.router import launch if __name__ == \"__main__\": launch() Routes Module \u00b6 # routes.py from routing.router import Route class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" class AboutRoute(Route): path = \"/about\" form = \"Pages.About\" class ContactRoute(Route): path = \"/contact\" form = \"Pages.Contact\" Navigation \u00b6 In Layouts.Main , include a SideBar and add 3 NavLink components. (The NavLink component should come from the routing library) Ensure the nav links have the following properties set: The first NavLink should have path=\"/\" . The second NavLink should have path=\"/about\" . The third NavLink should have path=\"/contact\" . Add a title slot to the Layouts.Main form. Inside Pages.Index , add a label component to the title slot with the text property set to \"Home\" . Do the same for Pages.About and Pages.Contact . You should now be able to navigate using the sidebar nav links. Troubleshooting \u00b6 If your routes aren't working, make sure your file structure is correct. The routes must be defined in the routes module. If you have named the routes module something else, you will need to change the configuration options for the routing library. See the API Reference for more information. Preferred: Set the routes_module config option so imports happen automatically. Alternatively , you can explicitly import the routes module in your startup form and server code: # In a startup module, e.g. startup.py from . import routes # In a server module, e.g. ServerRoutes.py from . import routes","title":"Quick Start"},{"location":"quick-start/#quick-start","text":"","title":"Quick Start"},{"location":"quick-start/#from-a-clone","text":"Clone the following Anvil app: https://anvil.works/build#clone:34ZTMM7IQRTCMIAD=PPWCEPHZKQ3VYBIEF6T7GWOY","title":"From a Clone"},{"location":"quick-start/#from-a-new-app","text":"Create a new app.","title":"From a New App"},{"location":"quick-start/#client-code-structure","text":"The client code structure should look like this: - Layouts (Package) - Main (Form - ensure you tick \"Use as layout\") - Pages (Package) - Index (Form choosing Layouts.Main as the layout) - About (Form choosing Layouts.Main as the layout) - Contact (Form choosing Layouts.Main as the layout) - routes (Module) - startup (Module)","title":"Client Code Structure"},{"location":"quick-start/#startup-module","text":"# startup.py from routing.router import launch if __name__ == \"__main__\": launch()","title":"Startup Module"},{"location":"quick-start/#routes-module","text":"# routes.py from routing.router import Route class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" class AboutRoute(Route): path = \"/about\" form = \"Pages.About\" class ContactRoute(Route): path = \"/contact\" form = \"Pages.Contact\"","title":"Routes Module"},{"location":"quick-start/#navigation","text":"In Layouts.Main , include a SideBar and add 3 NavLink components. (The NavLink component should come from the routing library) Ensure the nav links have the following properties set: The first NavLink should have path=\"/\" . The second NavLink should have path=\"/about\" . The third NavLink should have path=\"/contact\" . Add a title slot to the Layouts.Main form. Inside Pages.Index , add a label component to the title slot with the text property set to \"Home\" . Do the same for Pages.About and Pages.Contact . You should now be able to navigate using the sidebar nav links.","title":"Navigation"},{"location":"quick-start/#troubleshooting","text":"If your routes aren't working, make sure your file structure is correct. The routes must be defined in the routes module. If you have named the routes module something else, you will need to change the configuration options for the routing library. See the API Reference for more information. Preferred: Set the routes_module config option so imports happen automatically. Alternatively , you can explicitly import the routes module in your startup form and server code: # In a startup module, e.g. startup.py from . import routes # In a server module, e.g. ServerRoutes.py from . import routes","title":"Troubleshooting"},{"location":"caching/","text":"Caching \u00b6 The routing library provides simple caching mechanisms for forms and data. By default, the routing library will NOT cache any forms or data. Form Caching \u00b6 To override the default behaviour, you can set the Route.cache_form attribute to True . This will cause the routing library to cache all forms. from routing.router import Route Route.cache_form = True You can also set this attribute on specific routes. class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" cache_form = True Data Caching \u00b6 The routing library can cache data loaded by the load_data method. If you are not using the load_data method, you can skip this section. For more details, see the Data Loading section. You can enable data caching by setting the cache_data attribute on the route to True . Caching If you are using the load_data method and cache_form is set to True , then the load_data method will not be called if there is an existing cached form. Caching Keys \u00b6 The routing library will cache forms and data using a cache key. The key is a combination of the path and the dictionary returned by the cache_deps method. By default, the cache_deps method returns the query dictionary. Clearing Cache \u00b6 To clear all cached content, you can call the clear_cache function. from routing import router router.clear_cache() Invalidating Cache \u00b6 If you want to invalidate the cache for a specific path, you can call the invalidate function. Invalidating the cache will remove data and forms from the cache. from routing import router router.invalidate(path=\"/articles\") The call signature for invalidate is: invalidate(*, path=None, deps=None, exact=False) invalidate(path, **kws) invalidate(routing_context, **kws) path The path to invalidate. deps The dependencies to invalidate. These are the same dependencies that are returned by the cache_deps method. exact If True , then the path and deps must match exactly. If False (the default), then any path or deps that are a subset of the path and deps arguments will be invalidated. Partial Invalidation \u00b6 from routing.router import Route class ArticlesRoute(Route): path = \"/articles\" form = \"Pages.Articles\" class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" In the above example, if you call invalidate(\"/articles\", exact=True) , then data and forms associated with the ArticlesRoute will be invalidated. If you call invalidate(\"/articles\", exact=False) , then data and forms associated with the ArticlesRoute and all cached ArticleRoute instances will be invalidated, since the ArticleRoute path is a subset of the ArticlesRoute path. from routing.router import Route class ArticlesRoute(Route): path = \"/articles\" form = \"Pages.Articles\" def cache_deps(self, **loader_args): return {\"page\": loader_args[\"query\"][\"page\"]} def parse_query(self, query): return {**query, \"page\": int(query.get(\"page\", 1))} In the above example, the data is cached depending on the page query parameter. If you call invalidate(\"/articles\") , then all data associated with all pages will be invalidated. A deps value of {\"page\": 1} is considered a subset of an empty deps argument. If you call invalidate(\"/articles\", exact=True) , then no data will be invalidated, since there is no exact match. Calling invalidate(\"/articles\", deps={\"page\": 1}) will invalidate only the data for the first page. Invalidating Contexts \u00b6 A routing context also has an invalidate method for convenience. from routing import router class ArticleForm(ArticleFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context self.init_components(**properties) def delete_button_click(self, **event_args): self.remove_from_parent() self.routing_context.invalidate(exact=True)","title":"Caching"},{"location":"caching/#caching","text":"The routing library provides simple caching mechanisms for forms and data. By default, the routing library will NOT cache any forms or data.","title":"Caching"},{"location":"caching/#form-caching","text":"To override the default behaviour, you can set the Route.cache_form attribute to True . This will cause the routing library to cache all forms. from routing.router import Route Route.cache_form = True You can also set this attribute on specific routes. class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" cache_form = True","title":"Form Caching"},{"location":"caching/#data-caching","text":"The routing library can cache data loaded by the load_data method. If you are not using the load_data method, you can skip this section. For more details, see the Data Loading section. You can enable data caching by setting the cache_data attribute on the route to True . Caching If you are using the load_data method and cache_form is set to True , then the load_data method will not be called if there is an existing cached form.","title":"Data Caching"},{"location":"caching/#caching-keys","text":"The routing library will cache forms and data using a cache key. The key is a combination of the path and the dictionary returned by the cache_deps method. By default, the cache_deps method returns the query dictionary.","title":"Caching Keys"},{"location":"caching/#clearing-cache","text":"To clear all cached content, you can call the clear_cache function. from routing import router router.clear_cache()","title":"Clearing Cache"},{"location":"caching/#invalidating-cache","text":"If you want to invalidate the cache for a specific path, you can call the invalidate function. Invalidating the cache will remove data and forms from the cache. from routing import router router.invalidate(path=\"/articles\") The call signature for invalidate is: invalidate(*, path=None, deps=None, exact=False) invalidate(path, **kws) invalidate(routing_context, **kws) path The path to invalidate. deps The dependencies to invalidate. These are the same dependencies that are returned by the cache_deps method. exact If True , then the path and deps must match exactly. If False (the default), then any path or deps that are a subset of the path and deps arguments will be invalidated.","title":"Invalidating Cache"},{"location":"caching/#partial-invalidation","text":"from routing.router import Route class ArticlesRoute(Route): path = \"/articles\" form = \"Pages.Articles\" class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" In the above example, if you call invalidate(\"/articles\", exact=True) , then data and forms associated with the ArticlesRoute will be invalidated. If you call invalidate(\"/articles\", exact=False) , then data and forms associated with the ArticlesRoute and all cached ArticleRoute instances will be invalidated, since the ArticleRoute path is a subset of the ArticlesRoute path. from routing.router import Route class ArticlesRoute(Route): path = \"/articles\" form = \"Pages.Articles\" def cache_deps(self, **loader_args): return {\"page\": loader_args[\"query\"][\"page\"]} def parse_query(self, query): return {**query, \"page\": int(query.get(\"page\", 1))} In the above example, the data is cached depending on the page query parameter. If you call invalidate(\"/articles\") , then all data associated with all pages will be invalidated. A deps value of {\"page\": 1} is considered a subset of an empty deps argument. If you call invalidate(\"/articles\", exact=True) , then no data will be invalidated, since there is no exact match. Calling invalidate(\"/articles\", deps={\"page\": 1}) will invalidate only the data for the first page.","title":"Partial Invalidation"},{"location":"caching/#invalidating-contexts","text":"A routing context also has an invalidate method for convenience. from routing import router class ArticleForm(ArticleFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context self.init_components(**properties) def delete_button_click(self, **event_args): self.remove_from_parent() self.routing_context.invalidate(exact=True)","title":"Invalidating Contexts"},{"location":"contributing/","text":"Contributing \u00b6 We welcome contributions to the routing library! This document outlines the process for contributing to this project. Getting Started \u00b6 Fork the repository on GitHub Clone your fork locally: git clone https://github.com/YOUR-USERNAME/routing.git Create a new branch for your feature or fix: git checkout -b fix/<your-fix-name> or for a new feature: git checkout -b feat/<your-feature-name> or for a docs changes: git checkout -b docs/<your-docs-changes-name> Setting up Pre-commit \u00b6 We use pre-commit hooks to ensure code quality and consistency. To set this up: Install pre-commit: pip install pre-commit Install the git hooks: pre-commit install When you try to commit, these checks will run automatically. If any checks fail, the commit will be prevented and you'll need to fix the issues before committing again. To run the checks manually: pre-commit run --all-files Contributing to Documentation \u00b6 We use MkDocs for our documentation. To set up the documentation environment: Create and activate a virtual environment: pip install uv uv venv source .venv/bin/activate Install requirements: uv pip install -r requirements.txt Documentation files are in the docs/ directory and written in Markdown format. To preview your changes locally: mkdocs serve Then visit http://127.0.0.1:8000 in your browser. Documentation structure: docs/ \u251c\u2500\u2500 index.md # Main documentation page \u251c\u2500\u2500 file.md # Documentation page for file \u251c\u2500\u2500 folder/ \u2502 \u251c\u2500\u2500 index.md # Documentation page for folder \u2502 \u2514\u2500\u2500 file.md # Documentation page for file Follow these documentation guidelines: Use British English Keep paragraphs concise and focused Include code examples where appropriate Add screenshots for UI-related features Update the navigation in mkdocs.yml if adding new pages Check for broken links and formatting issues before submitting Making Changes \u00b6 Make your changes in your feature branch Write or update tests as needed Ensure your code follows the existing style of the project Commit your changes: git commit -m \"Description of your changes\" Submitting Changes \u00b6 Push your changes to your fork on GitHub: git push origin <your-branch-name> Open a Pull Request (PR) from your fork to our main repository In your PR description, clearly describe: What changes you've made Why you've made them Any relevant issue numbers Pull Request Guidelines \u00b6 PRs should focus on a single feature or fix Keep changes small and focused Update documentation as needed Ensure all tests pass Follow existing code style and conventions All pre-commit checks must pass For documentation changes: Ensure mkdocs builds successfully Preview changes locally before submitting Check for broken links and proper formatting Questions or Issues? \u00b6 If you have questions or run into issues, please: Check existing issues on GitHub Create a new issue if needed Ask questions in the PR itself Thank you for contributing to the routing library!","title":"Contributing"},{"location":"contributing/#contributing","text":"We welcome contributions to the routing library! This document outlines the process for contributing to this project.","title":"Contributing"},{"location":"contributing/#getting-started","text":"Fork the repository on GitHub Clone your fork locally: git clone https://github.com/YOUR-USERNAME/routing.git Create a new branch for your feature or fix: git checkout -b fix/<your-fix-name> or for a new feature: git checkout -b feat/<your-feature-name> or for a docs changes: git checkout -b docs/<your-docs-changes-name>","title":"Getting Started"},{"location":"contributing/#setting-up-pre-commit","text":"We use pre-commit hooks to ensure code quality and consistency. To set this up: Install pre-commit: pip install pre-commit Install the git hooks: pre-commit install When you try to commit, these checks will run automatically. If any checks fail, the commit will be prevented and you'll need to fix the issues before committing again. To run the checks manually: pre-commit run --all-files","title":"Setting up Pre-commit"},{"location":"contributing/#contributing-to-documentation","text":"We use MkDocs for our documentation. To set up the documentation environment: Create and activate a virtual environment: pip install uv uv venv source .venv/bin/activate Install requirements: uv pip install -r requirements.txt Documentation files are in the docs/ directory and written in Markdown format. To preview your changes locally: mkdocs serve Then visit http://127.0.0.1:8000 in your browser. Documentation structure: docs/ \u251c\u2500\u2500 index.md # Main documentation page \u251c\u2500\u2500 file.md # Documentation page for file \u251c\u2500\u2500 folder/ \u2502 \u251c\u2500\u2500 index.md # Documentation page for folder \u2502 \u2514\u2500\u2500 file.md # Documentation page for file Follow these documentation guidelines: Use British English Keep paragraphs concise and focused Include code examples where appropriate Add screenshots for UI-related features Update the navigation in mkdocs.yml if adding new pages Check for broken links and formatting issues before submitting","title":"Contributing to Documentation"},{"location":"contributing/#making-changes","text":"Make your changes in your feature branch Write or update tests as needed Ensure your code follows the existing style of the project Commit your changes: git commit -m \"Description of your changes\"","title":"Making Changes"},{"location":"contributing/#submitting-changes","text":"Push your changes to your fork on GitHub: git push origin <your-branch-name> Open a Pull Request (PR) from your fork to our main repository In your PR description, clearly describe: What changes you've made Why you've made them Any relevant issue numbers","title":"Submitting Changes"},{"location":"contributing/#pull-request-guidelines","text":"PRs should focus on a single feature or fix Keep changes small and focused Update documentation as needed Ensure all tests pass Follow existing code style and conventions All pre-commit checks must pass For documentation changes: Ensure mkdocs builds successfully Preview changes locally before submitting Check for broken links and proper formatting","title":"Pull Request Guidelines"},{"location":"contributing/#questions-or-issues","text":"If you have questions or run into issues, please: Check existing issues on GitHub Create a new issue if needed Ask questions in the PR itself Thank you for contributing to the routing library!","title":"Questions or Issues?"},{"location":"data-loading/","text":"Data Loading \u00b6 The load_data method allows data to be sent from the server during the initial page request, rather than loading data during form instantiation. Most apps will not need to use the load_data method and will load data during the form's instantiation or pass data through form properties. Many of the advantages of data loading can be achieved by using cached forms . Limitations \u00b6 Since the routing library takes advantage of client-side routing after the initial page request, the advantages of data loading are limited to the first page request. Data caching is determined by the path and the dictionary returned by the cache_deps method. If your App needs to share data between routes, you may find that data caching is not sufficient and results in duplicate data being loaded. You can mitigate duplicate data by using form_properties or nav_context for simple data sharing. Example \u00b6 Without a load_data method # routes.py from routing.router import Route Route.cache_form = True class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" from routing import router class ArticleForm(ArticleFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context if properties.get(\"item\") is None: # The user navigated directly to the form by changing the URL properties[\"item\"] = anvil.server.call(\"get_article\", routing_context.params[\"id\"]) self.init_components(**properties) In the above example, if a user goes directly to the URL /articles/123 , the initial page request will send the user to the ArticleForm , but there will be no data. The App will then need to make a server call to get the data. Note that during normal navigation, i.e. when the user clicks a link, we can take advantage of the form_properties attribute to ensure we do not load unnecessary data. class RowTemplate(RowTemplateTemplate): def __init__(self, **properties): self.init_components(**properties) def on_button_click(self, **event_args): router.navigate( path=\"/articles/:id\", params={\"id\": self.item[\"id\"]}, form_properties={\"item\": self.item} ) With a load_data method # routes.py from routing.router import Route class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" def load_data(self, **loader_args): row = loader_args[\"nav_context\"].get(\"row\") if row is None: id = loader_args[\"path_params\"][\"id\"] row = anvil.server.call(\"get_row\", id) return row from routing import router class ArticleForm(ArticleFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context properties[\"item\"] = routing_context.data self.init_components(**properties) In the above example, the load_data is called whenever the user navigates. If a user navigates directly to the URL /articles/123 , the initial page request will come in, the load_data method will be called (on the server), and the user will be directed to the ArticleForm with the data already loaded. During normal navigation, i.e. when the user clicks a link, we can take advantage of the nav_context (or form_properties ) attribute to ensure we do not make unnecessary server calls during client-side navigation. class RowTemplate(RowTemplateTemplate): def __init__(self, **properties): self.init_components(**properties) def on_button_click(self, **event_args): router.navigate( path=\"/articles/:id\", params={\"id\": self.item[\"id\"]}, nav_context={\"row\": self.item} ) Invalidating Data \u00b6 See Invalidating Cache . Pending Form \u00b6 When data is loading for the first time, a user can provide a loading form. This form will be shown while the data is loading. The pending form is determined by the Route.pending_form attribute. When the data is loading, the routing library will wait for the pending_delay seconds before showing the pending form. It will show the pending form for at least pending_min seconds. from routing.router import Route class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" pending_form = \"Pages.Loading\" pending_delay = 1 # default is 1 pending_min = 0.5 # default is 0.5 A common implementation will be to create a pending form with the same layout as the form. Where the content would be, place an Anvil.Spacer component. Inside the show and hide event handlers, call the anvil.server.loading_indicator.start and anvil.server.loading_indicator.stop functions. from anvil.server import loading_indicator class LoadingForm(LoadingFormTemplate): def __init__(self, **properties): self.init_components(**properties) self.loading_indicator = anvil.server.loading_indicator(self.spacer_1) def show(self, **event_args): self.loading_indicator.start() def hide(self, **event_args): self.loading_indicator.stop()","title":"Data Loading"},{"location":"data-loading/#data-loading","text":"The load_data method allows data to be sent from the server during the initial page request, rather than loading data during form instantiation. Most apps will not need to use the load_data method and will load data during the form's instantiation or pass data through form properties. Many of the advantages of data loading can be achieved by using cached forms .","title":"Data Loading"},{"location":"data-loading/#limitations","text":"Since the routing library takes advantage of client-side routing after the initial page request, the advantages of data loading are limited to the first page request. Data caching is determined by the path and the dictionary returned by the cache_deps method. If your App needs to share data between routes, you may find that data caching is not sufficient and results in duplicate data being loaded. You can mitigate duplicate data by using form_properties or nav_context for simple data sharing.","title":"Limitations"},{"location":"data-loading/#example","text":"Without a load_data method # routes.py from routing.router import Route Route.cache_form = True class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" from routing import router class ArticleForm(ArticleFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context if properties.get(\"item\") is None: # The user navigated directly to the form by changing the URL properties[\"item\"] = anvil.server.call(\"get_article\", routing_context.params[\"id\"]) self.init_components(**properties) In the above example, if a user goes directly to the URL /articles/123 , the initial page request will send the user to the ArticleForm , but there will be no data. The App will then need to make a server call to get the data. Note that during normal navigation, i.e. when the user clicks a link, we can take advantage of the form_properties attribute to ensure we do not load unnecessary data. class RowTemplate(RowTemplateTemplate): def __init__(self, **properties): self.init_components(**properties) def on_button_click(self, **event_args): router.navigate( path=\"/articles/:id\", params={\"id\": self.item[\"id\"]}, form_properties={\"item\": self.item} ) With a load_data method # routes.py from routing.router import Route class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" def load_data(self, **loader_args): row = loader_args[\"nav_context\"].get(\"row\") if row is None: id = loader_args[\"path_params\"][\"id\"] row = anvil.server.call(\"get_row\", id) return row from routing import router class ArticleForm(ArticleFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context properties[\"item\"] = routing_context.data self.init_components(**properties) In the above example, the load_data is called whenever the user navigates. If a user navigates directly to the URL /articles/123 , the initial page request will come in, the load_data method will be called (on the server), and the user will be directed to the ArticleForm with the data already loaded. During normal navigation, i.e. when the user clicks a link, we can take advantage of the nav_context (or form_properties ) attribute to ensure we do not make unnecessary server calls during client-side navigation. class RowTemplate(RowTemplateTemplate): def __init__(self, **properties): self.init_components(**properties) def on_button_click(self, **event_args): router.navigate( path=\"/articles/:id\", params={\"id\": self.item[\"id\"]}, nav_context={\"row\": self.item} )","title":"Example"},{"location":"data-loading/#invalidating-data","text":"See Invalidating Cache .","title":"Invalidating Data"},{"location":"data-loading/#pending-form","text":"When data is loading for the first time, a user can provide a loading form. This form will be shown while the data is loading. The pending form is determined by the Route.pending_form attribute. When the data is loading, the routing library will wait for the pending_delay seconds before showing the pending form. It will show the pending form for at least pending_min seconds. from routing.router import Route class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" pending_form = \"Pages.Loading\" pending_delay = 1 # default is 1 pending_min = 0.5 # default is 0.5 A common implementation will be to create a pending form with the same layout as the form. Where the content would be, place an Anvil.Spacer component. Inside the show and hide event handlers, call the anvil.server.loading_indicator.start and anvil.server.loading_indicator.stop functions. from anvil.server import loading_indicator class LoadingForm(LoadingFormTemplate): def __init__(self, **properties): self.init_components(**properties) self.loading_indicator = anvil.server.loading_indicator(self.spacer_1) def show(self, **event_args): self.loading_indicator.start() def hide(self, **event_args): self.loading_indicator.stop()","title":"Pending Form"},{"location":"migrating/","text":"Migrating \u00b6 From an app that navigates with anvil.open_form \u00b6 Define your routes. If you are not using params in any routes, you should be able to replace all calls to anvil.open_form with router.open_form . To begin with, make sure to set cached_forms to False . As you decide certain routes should have params , you will need to replace router.open_form with router.navigate . The keyword arguments to open_form will be a dictionary you pass to the form_properties argument of navigate . A common pitfall will be that a Form could previously rely on the item property always being passed to the form. However, this will not be the case if a user navigates directly to the form. In this case, the item property will be None , and you will have to fetch the item based on the routing_context . From anvil_extras.routing ( HashRouting ) \u00b6 Define your routes. Each route definition will be similar to the hash routing @route decorator. By default, when a route subclasses from Route , the routing library will call anvil.open_form on the matching route's form. For hash routing apps, this is not what you want. Instead, you should subclass from TemplateWithContainerRoute and set the template attribute to the template form. from routing.router import TemplateWithContainerRoute as BaseRoute BaseRoute.template = \"MainTemplate\" class IndexRoute(BaseRoute): path = \"/\" form = \"Pages.Index\" If you have a single template in your hash routing app, then set BaseRoute.template = \"MyTemplate\" . If you have multiple templates, then you can set the template attribute on individual routes. See the section below that elaborates on how to work with multiple templates. set_url_hash \u00b6 Instead of calling hash routing's set_url_hash method, use the navigate function. Or, if the set_url_hash call is inside a Link 's click handler, replace the Link with a NavLink / Anchor . Set the path and query attribute appropriately and remove the click handler. full_width_row \u00b6 If the route decorator uses full_width_row , you should configure the Route.template_container_properties attribute. from routing.router import TemplateWithContainerRoute as BaseRoute BaseRoute.template = \"MainTemplate\" class IndexRoute(BaseRoute): path = \"/\" form = \"Pages.Index\" template_container_properties = {\"full_width_row\": True} If you are using full_width_row on all routes then you can set the full_width_row attribute on the Route class. from routing.router import TemplateWithContainerRoute as BaseRoute BaseRoute.template = \"MainTemplate\" BaseRoute.template_container_properties = {\"full_width_row\": True} Navigation Links \u00b6 Replace regular HTML links with NavLink components. Instead of using click handlers and manually managing navigation, configure the path directly on the component (either in code or in the designer): from ._anvil_designer import MainTemplate from routing import router class Main(MainTemplate): def __init__(self, **properties): self.nav_home.path = '/home' self.nav_settings.path = '/settings' self.init_components(**properties) NavLinks provide several advantages: - Automatic active state management - Support for ctrl+click to open in new tab - Native browser link preview behavior - No need for click handlers - Improved accessibility on_navigation callback \u00b6 In hash routing the on_navigation method is called on the Template form when the hash changes. This is often used to update the active nav link in the sidebar. If you are using Link components in your sidebar, we recommend replacing these with NavLink components (see previous section). If you want to keep your existing on_navigation method, you can achieve this through the router 's event system. The router will emit a navigation event when the url changes. from ._anvil_designer import MainTemplate from routing import router class Main(MainTemplate): def __init__(self, **properties): self.links = {\"/\": self.home_nav, \"/about\": self.about_nav} self.init_components(**properties) def on_navigate(self, **event_args): context = router.get_routing_context() for path, link in self.links.items(): if path == context.path: link.role = \"selected\" else: link.role = None def home_nav_click(self, **event_args): router.navigate(\"/\") def about_nav_click(self, **event_args): router.navigate(\"/about\") def form_show(self, **event_args): router.add_event_handler(\"navigate\", self.on_navigate) self.on_navigate() def form_hide(self, **event_args): router.remove_event_handler(\"navigate\", self.on_navigate) If you have multiple Templates, we recommend subscribing to the navigation event in the form_show method of your template form, and unsubscribing in the form_hide method. If you only have a single template, you can subscribe to the navigation event in the __init__ method of your template form and there is no need to unsubscribe. Using multiple templates, redirects, and other advanced usage \u00b6 When migrating from anvil_extras, you might have different templates for different parts of your application. For example, you might have: - A main template with navigation for authenticated users - A minimal template for authentication pages - A specialized template for admin sections You can configure this by setting different templates for different routes. You can also configure redirects and caching settings within each route class. Below is an example with two templates - one for authentication and one for the main app. from routing.router import TemplateWithContainerRoute as BaseRoute from routing.router import Redirect from .Global import Global # if you have a module for global (cached) variables class EnsureUserMixin: def before_load(self, **loader_args): # Runs this method before loading the route form. if not Global.user: # Redirect if there is no logged in user. raise Redirect(path=\"/signin\") class SigninRoute(BaseRoute): template = 'Templates.Static' # Template for auth screen path = '/signin' form = 'Pages.Signin' cache_form = True # Cache settings for this route form. class SignupRoute(BaseRoute): template = 'Templates.Static' # Template for auth screen path = '/signup' form = 'Pages.Signup' cache_form = True class HomeRoute(EnsureUserMixin, BaseRoute): # This route and ones below inherits from two classes, # which propagates the redirect from EnsureUserMixin template = 'Templates.Router' # Main template for app path = '/app/home' form = 'Pages.Home' cache_form = True class SettingsRoute(EnsureUserMixin, BaseRoute): template = 'Templates.Router' path = '/app/settings' form = 'Pages.Settings' cache_form = True class AdminRoute(EnsureUserMixin, BaseRoute): template = 'Templates.Router' path = '/app/admin' form = 'Pages.Admin' cache_form = True Note that redirects are no longer defined in the startup form, but the routes module. In addition, caching is defined for each route, not as a parameter in the navigation function (anvil_extras set_url_hash ). Any common attributes and methods can be set on base classes or mix-in classes.","title":"Migrating"},{"location":"migrating/#migrating","text":"","title":"Migrating"},{"location":"migrating/#from-an-app-that-navigates-with-anvilopen_form","text":"Define your routes. If you are not using params in any routes, you should be able to replace all calls to anvil.open_form with router.open_form . To begin with, make sure to set cached_forms to False . As you decide certain routes should have params , you will need to replace router.open_form with router.navigate . The keyword arguments to open_form will be a dictionary you pass to the form_properties argument of navigate . A common pitfall will be that a Form could previously rely on the item property always being passed to the form. However, this will not be the case if a user navigates directly to the form. In this case, the item property will be None , and you will have to fetch the item based on the routing_context .","title":"From an app that navigates with anvil.open_form"},{"location":"migrating/#from-anvil_extrasrouting-hashrouting","text":"Define your routes. Each route definition will be similar to the hash routing @route decorator. By default, when a route subclasses from Route , the routing library will call anvil.open_form on the matching route's form. For hash routing apps, this is not what you want. Instead, you should subclass from TemplateWithContainerRoute and set the template attribute to the template form. from routing.router import TemplateWithContainerRoute as BaseRoute BaseRoute.template = \"MainTemplate\" class IndexRoute(BaseRoute): path = \"/\" form = \"Pages.Index\" If you have a single template in your hash routing app, then set BaseRoute.template = \"MyTemplate\" . If you have multiple templates, then you can set the template attribute on individual routes. See the section below that elaborates on how to work with multiple templates.","title":"From anvil_extras.routing (HashRouting)"},{"location":"migrating/#set_url_hash","text":"Instead of calling hash routing's set_url_hash method, use the navigate function. Or, if the set_url_hash call is inside a Link 's click handler, replace the Link with a NavLink / Anchor . Set the path and query attribute appropriately and remove the click handler.","title":"set_url_hash"},{"location":"migrating/#full_width_row","text":"If the route decorator uses full_width_row , you should configure the Route.template_container_properties attribute. from routing.router import TemplateWithContainerRoute as BaseRoute BaseRoute.template = \"MainTemplate\" class IndexRoute(BaseRoute): path = \"/\" form = \"Pages.Index\" template_container_properties = {\"full_width_row\": True} If you are using full_width_row on all routes then you can set the full_width_row attribute on the Route class. from routing.router import TemplateWithContainerRoute as BaseRoute BaseRoute.template = \"MainTemplate\" BaseRoute.template_container_properties = {\"full_width_row\": True}","title":"full_width_row"},{"location":"migrating/#navigation-links","text":"Replace regular HTML links with NavLink components. Instead of using click handlers and manually managing navigation, configure the path directly on the component (either in code or in the designer): from ._anvil_designer import MainTemplate from routing import router class Main(MainTemplate): def __init__(self, **properties): self.nav_home.path = '/home' self.nav_settings.path = '/settings' self.init_components(**properties) NavLinks provide several advantages: - Automatic active state management - Support for ctrl+click to open in new tab - Native browser link preview behavior - No need for click handlers - Improved accessibility","title":"Navigation Links"},{"location":"migrating/#on_navigation-callback","text":"In hash routing the on_navigation method is called on the Template form when the hash changes. This is often used to update the active nav link in the sidebar. If you are using Link components in your sidebar, we recommend replacing these with NavLink components (see previous section). If you want to keep your existing on_navigation method, you can achieve this through the router 's event system. The router will emit a navigation event when the url changes. from ._anvil_designer import MainTemplate from routing import router class Main(MainTemplate): def __init__(self, **properties): self.links = {\"/\": self.home_nav, \"/about\": self.about_nav} self.init_components(**properties) def on_navigate(self, **event_args): context = router.get_routing_context() for path, link in self.links.items(): if path == context.path: link.role = \"selected\" else: link.role = None def home_nav_click(self, **event_args): router.navigate(\"/\") def about_nav_click(self, **event_args): router.navigate(\"/about\") def form_show(self, **event_args): router.add_event_handler(\"navigate\", self.on_navigate) self.on_navigate() def form_hide(self, **event_args): router.remove_event_handler(\"navigate\", self.on_navigate) If you have multiple Templates, we recommend subscribing to the navigation event in the form_show method of your template form, and unsubscribing in the form_hide method. If you only have a single template, you can subscribe to the navigation event in the __init__ method of your template form and there is no need to unsubscribe.","title":"on_navigation callback"},{"location":"migrating/#using-multiple-templates-redirects-and-other-advanced-usage","text":"When migrating from anvil_extras, you might have different templates for different parts of your application. For example, you might have: - A main template with navigation for authenticated users - A minimal template for authentication pages - A specialized template for admin sections You can configure this by setting different templates for different routes. You can also configure redirects and caching settings within each route class. Below is an example with two templates - one for authentication and one for the main app. from routing.router import TemplateWithContainerRoute as BaseRoute from routing.router import Redirect from .Global import Global # if you have a module for global (cached) variables class EnsureUserMixin: def before_load(self, **loader_args): # Runs this method before loading the route form. if not Global.user: # Redirect if there is no logged in user. raise Redirect(path=\"/signin\") class SigninRoute(BaseRoute): template = 'Templates.Static' # Template for auth screen path = '/signin' form = 'Pages.Signin' cache_form = True # Cache settings for this route form. class SignupRoute(BaseRoute): template = 'Templates.Static' # Template for auth screen path = '/signup' form = 'Pages.Signup' cache_form = True class HomeRoute(EnsureUserMixin, BaseRoute): # This route and ones below inherits from two classes, # which propagates the redirect from EnsureUserMixin template = 'Templates.Router' # Main template for app path = '/app/home' form = 'Pages.Home' cache_form = True class SettingsRoute(EnsureUserMixin, BaseRoute): template = 'Templates.Router' path = '/app/settings' form = 'Pages.Settings' cache_form = True class AdminRoute(EnsureUserMixin, BaseRoute): template = 'Templates.Router' path = '/app/admin' form = 'Pages.Admin' cache_form = True Note that redirects are no longer defined in the startup form, but the routes module. In addition, caching is defined for each route, not as a parameter in the navigation function (anvil_extras set_url_hash ). Any common attributes and methods can be set on base classes or mix-in classes.","title":"Using multiple templates, redirects, and other advanced usage"},{"location":"navigating/","text":"Navigation \u00b6 There are two ways to navigate. The first is with the navigate function, and the second is with a navigation component . Navigating with navigate \u00b6 The navigate function lets you navigate to a specific path through code. It is a function that you will likely call from a click handler. Do note that the navigate function can only be called from client code. from routing.router import navigate class Form(FormTemplate): def nav_button_click(self, **event_args): navigate(path=\"/articles/:id\", params={\"id\": 123}) Call Signatures \u00b6 navigate(*, path=None, params=None, query=None, hash=None, replace=False, nav_context=None, form_properties=None) use keyword arguments only navigate(path, **kws) the first argument can be the path navigate(url, **kws) the first argument can be a URL navigate(routing_context, **kws) the first argument can be a routing context Arguments \u00b6 path The path to navigate to. e.g. /articles/123 or /articles or /articles/:id . The path can be relative ./ . If not set, then the path will be the current path. params The params for the path. e.g. {\"id\": 123} query The query parameters to navigate to. e.g. {\"tab\": \"income\"} . This can be a function that takes the current query parameters as an argument and returns the new query parameters. If you provide a query function, avoid modifying the query parameters directly, instead return a new dictionary. def on_button_click(self, **event_args): def query(prev): return {**prev, \"open\": not prev.get(\"open\", False)} navigate(query=query) hash The hash to navigate to. replace If True , then the current URL will be replaced with the new URL (default is False ). nav_context The nav context for this navigation. form_properties The form properties to pass to the form when it is opened. Use of form_properties \u00b6 The form_properties is a dictionary that is passed to the open_form function. A common use case is to pass the form's item property. Note that if you are relying on form_properties , you will always need to account for form_properties being an empty dictionary when the user navigates by changing the URL directly. from routing import router class RowTemplate(RowTemplateTemplate): def __init__(self, **properties): self.init_components(**properties) def button_click(self, **event_args): router.navigate( path=\"/articles/:id\", params={\"id\": self.item[\"id\"]}, form_properties={\"item\": self.item} ) And then in the /articles/:id route: from routing import router class ArticleForm(ArticleFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context if properties.get(\"item\") is None: # The user navigated directly # to the form by changing the URL article_id = routing_context.params[\"id\"] properties[\"item\"] = anvil.server.call(\"get_article\", article_id) self.init_components(**properties) Use of nav_context \u00b6 The nav_context is a dictionary that is passed to the navigate function. A use case for this is to pass the previous routing context to the next routing context. This is useful when you want to navigate to a new route but want to preserve the previous route's data, particularly if the previous route uses query parameters that determine the state of the form. from routing import router def on_button_click(self, **event_args): current_context = router.get_routing_context() router.navigate(path=\"/foo\", nav_context={\"prev_context\": current_context}) And then in the /foo route: from routing import router class FooForm(FooFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context self.init_components(**properties) def cancel_button_click(self, **event_args): prev_context = self.routing_context.nav_context.get(\"prev_context\") if prev_context is not None: router.navigate(prev_context) else: # No nav-context - the user navigated directly to the form by changing the URL router.navigate(path=\"/\") Updating nav_context from before_load \u00b6 You can also update the navigation context from a route's before_load method by returning a dictionary. The returned dictionary will be merged into nav_context for the route: class DashboardRoute(Route): path = \"/dashboard\" form = \"Pages.Dashboard\" def before_load(self, **loader_args): # Add a value to nav_context for this navigation return {\"show_sidebar\": True} In this example, routing_context.nav_context[\"show_sidebar\"] will be True when the form is loaded. Advanced: Composing hooks.before_loads \u00b6 The @hooks.before_load decorator enables you to compose multiple hooks for a single route, supporting advanced patterns such as mixins, inheritance, and global hooks. Multiple Hooks and Inheritance \u00b6 Hooks are collected from all base classes in method resolution order (MRO), so you can layer behaviors: from routing.router import Route, hooks, Redirect class AuthenticatedRoute(Route): @hooks.before_load def check_auth(self, **loader_args): if not user_is_authenticated(): raise Redirect(path=\"/login\") return {\"user\": get_current_user()} class FeatureFlagMixin: @hooks.before_load def add_feature_flag(self, **loader_args): return {\"feature_enabled\": True} class DashboardRoute(FeatureFlagMixin, AuthenticatedRoute): path = \"/dashboard\" form = \"Pages.Dashboard\" @hooks.before_load def dashboard_flag(self, **loader_args): return {\"show_dashboard\": True} Hooks will run in base-to-leaf order: check_auth \u2192 add_feature_flag \u2192 dashboard_flag . Global Hooks \u00b6 You can attach a hook to the Route base class to apply it to all routes: @hooks.before_load def global_hook(self, **loader_args): # e.g., add analytics or logging return {\"analytics_id\": \"xyz\"} Route.global_hook = global_hook Best Practices \u00b6 Each hook should return only the context it wants to add (or raise for control flow). Hooks should expect a nav_context kwarg and can read or update it for composable navigation logic. Hooks may also return a dict with additional context to be merged into nav_context after the hook runs. This allows both direct mutation and returned values to contribute to the final context. Use mixins or base classes to share common hooks across multiple routes. Global hooks are powerful for cross-cutting concerns, but use them judiciously to avoid surprises. Example: from routing.router import Route, hooks, Redirect, Redirect class AuthenticatedRoute(Route): @hooks.before_load def set_user(self, nav_context, **loader_args): nav_context[\"user\"] = get_current_user() @hooks.before_load def check_permissions(self, nav_context, **loader_args): user = nav_context.get(\"user\") if not user or not user.has_permission(): raise Redirect(path=\"/login\") class FeatureRoute(AuthenticatedRoute): @hooks.before_load def add_feature_flag(self, nav_context, **loader_args): nav_context[\"feature_enabled\"] = True Hooks are called in order, and each can build on the output of previous hooks via nav_context .","title":"Navigation"},{"location":"navigating/#navigation","text":"There are two ways to navigate. The first is with the navigate function, and the second is with a navigation component .","title":"Navigation"},{"location":"navigating/#navigating-with-navigate","text":"The navigate function lets you navigate to a specific path through code. It is a function that you will likely call from a click handler. Do note that the navigate function can only be called from client code. from routing.router import navigate class Form(FormTemplate): def nav_button_click(self, **event_args): navigate(path=\"/articles/:id\", params={\"id\": 123})","title":"Navigating with navigate"},{"location":"navigating/#call-signatures","text":"navigate(*, path=None, params=None, query=None, hash=None, replace=False, nav_context=None, form_properties=None) use keyword arguments only navigate(path, **kws) the first argument can be the path navigate(url, **kws) the first argument can be a URL navigate(routing_context, **kws) the first argument can be a routing context","title":"Call Signatures"},{"location":"navigating/#arguments","text":"path The path to navigate to. e.g. /articles/123 or /articles or /articles/:id . The path can be relative ./ . If not set, then the path will be the current path. params The params for the path. e.g. {\"id\": 123} query The query parameters to navigate to. e.g. {\"tab\": \"income\"} . This can be a function that takes the current query parameters as an argument and returns the new query parameters. If you provide a query function, avoid modifying the query parameters directly, instead return a new dictionary. def on_button_click(self, **event_args): def query(prev): return {**prev, \"open\": not prev.get(\"open\", False)} navigate(query=query) hash The hash to navigate to. replace If True , then the current URL will be replaced with the new URL (default is False ). nav_context The nav context for this navigation. form_properties The form properties to pass to the form when it is opened.","title":"Arguments"},{"location":"navigating/#use-of-form_properties","text":"The form_properties is a dictionary that is passed to the open_form function. A common use case is to pass the form's item property. Note that if you are relying on form_properties , you will always need to account for form_properties being an empty dictionary when the user navigates by changing the URL directly. from routing import router class RowTemplate(RowTemplateTemplate): def __init__(self, **properties): self.init_components(**properties) def button_click(self, **event_args): router.navigate( path=\"/articles/:id\", params={\"id\": self.item[\"id\"]}, form_properties={\"item\": self.item} ) And then in the /articles/:id route: from routing import router class ArticleForm(ArticleFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context if properties.get(\"item\") is None: # The user navigated directly # to the form by changing the URL article_id = routing_context.params[\"id\"] properties[\"item\"] = anvil.server.call(\"get_article\", article_id) self.init_components(**properties)","title":"Use of form_properties"},{"location":"navigating/#use-of-nav_context","text":"The nav_context is a dictionary that is passed to the navigate function. A use case for this is to pass the previous routing context to the next routing context. This is useful when you want to navigate to a new route but want to preserve the previous route's data, particularly if the previous route uses query parameters that determine the state of the form. from routing import router def on_button_click(self, **event_args): current_context = router.get_routing_context() router.navigate(path=\"/foo\", nav_context={\"prev_context\": current_context}) And then in the /foo route: from routing import router class FooForm(FooFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context self.init_components(**properties) def cancel_button_click(self, **event_args): prev_context = self.routing_context.nav_context.get(\"prev_context\") if prev_context is not None: router.navigate(prev_context) else: # No nav-context - the user navigated directly to the form by changing the URL router.navigate(path=\"/\")","title":"Use of nav_context"},{"location":"navigating/#updating-nav_context-from-before_load","text":"You can also update the navigation context from a route's before_load method by returning a dictionary. The returned dictionary will be merged into nav_context for the route: class DashboardRoute(Route): path = \"/dashboard\" form = \"Pages.Dashboard\" def before_load(self, **loader_args): # Add a value to nav_context for this navigation return {\"show_sidebar\": True} In this example, routing_context.nav_context[\"show_sidebar\"] will be True when the form is loaded.","title":"Updating nav_context from before_load"},{"location":"navigating/#advanced-composing-hooksbefore_loads","text":"The @hooks.before_load decorator enables you to compose multiple hooks for a single route, supporting advanced patterns such as mixins, inheritance, and global hooks.","title":"Advanced: Composing hooks.before_loads"},{"location":"navigating/#multiple-hooks-and-inheritance","text":"Hooks are collected from all base classes in method resolution order (MRO), so you can layer behaviors: from routing.router import Route, hooks, Redirect class AuthenticatedRoute(Route): @hooks.before_load def check_auth(self, **loader_args): if not user_is_authenticated(): raise Redirect(path=\"/login\") return {\"user\": get_current_user()} class FeatureFlagMixin: @hooks.before_load def add_feature_flag(self, **loader_args): return {\"feature_enabled\": True} class DashboardRoute(FeatureFlagMixin, AuthenticatedRoute): path = \"/dashboard\" form = \"Pages.Dashboard\" @hooks.before_load def dashboard_flag(self, **loader_args): return {\"show_dashboard\": True} Hooks will run in base-to-leaf order: check_auth \u2192 add_feature_flag \u2192 dashboard_flag .","title":"Multiple Hooks and Inheritance"},{"location":"navigating/#global-hooks","text":"You can attach a hook to the Route base class to apply it to all routes: @hooks.before_load def global_hook(self, **loader_args): # e.g., add analytics or logging return {\"analytics_id\": \"xyz\"} Route.global_hook = global_hook","title":"Global Hooks"},{"location":"navigating/#best-practices","text":"Each hook should return only the context it wants to add (or raise for control flow). Hooks should expect a nav_context kwarg and can read or update it for composable navigation logic. Hooks may also return a dict with additional context to be merged into nav_context after the hook runs. This allows both direct mutation and returned values to contribute to the final context. Use mixins or base classes to share common hooks across multiple routes. Global hooks are powerful for cross-cutting concerns, but use them judiciously to avoid surprises. Example: from routing.router import Route, hooks, Redirect, Redirect class AuthenticatedRoute(Route): @hooks.before_load def set_user(self, nav_context, **loader_args): nav_context[\"user\"] = get_current_user() @hooks.before_load def check_permissions(self, nav_context, **loader_args): user = nav_context.get(\"user\") if not user or not user.has_permission(): raise Redirect(path=\"/login\") class FeatureRoute(AuthenticatedRoute): @hooks.before_load def add_feature_flag(self, nav_context, **loader_args): nav_context[\"feature_enabled\"] = True Hooks are called in order, and each can build on the output of previous hooks via nav_context .","title":"Best Practices"},{"location":"navigating/blocking-navigation/","text":"Blocking Navigation \u00b6 You may want to prevent the user from navigating away from a page, for example, if they are editing a form. from routing.router import RoutingContext, navigate class EditForm(EditFormTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.routing_context = routing_context self.routing_context.register_blocker(self.prevent_navigation) self.init_components(**properties) def prevent_navigation(self, **event_args): c = confirm(\"Are you sure you want to leave this page? Your changes will be lost.\") return not c def save_button_click(self, **event_args): self.routing_context.unregister_blocker(self.prevent_navigation) navigate(path=\"/dashboard\") Note When you register a blocker, if a user navigates to another website, the browser dialogue asking if they want to leave the current page will be shown. Alternatively, you can use the NavigationBlocker context manager. from routing.router import NavigationBlocker class Form(FormTemplate): def __init__(self, **properties): self.init_components(**properties) def run_important_alert(self, **event_args): with NavigationBlocker(warn_before_unload=True): alert(\"Important Alert\", dismissible=False) The above navigation blocker will prevent the user from navigating away from the page while the alert is open. warn_before_unload will show the browser dialogue asking if the user wants to leave the page if they navigate to a new website. By default, this is False . Alerts \u00b6 The alert and confirm functions are provided by the routing library. These functions behave similarly to Anvil's default alert and confirm functions, but they will block navigation when dismissible is True , or close the alert when the user navigates to a new page. You can override the default alert and confirm functions by setting the anvil.alert and anvil.confirm attributes in your startup module. # startup.py import anvil from routing import router from . import routes anvil.alert = router.alert anvil.confirm = router.confirm if __name__ == \"__main__\": router.launch()","title":"Blocking Navigation"},{"location":"navigating/blocking-navigation/#blocking-navigation","text":"You may want to prevent the user from navigating away from a page, for example, if they are editing a form. from routing.router import RoutingContext, navigate class EditForm(EditFormTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.routing_context = routing_context self.routing_context.register_blocker(self.prevent_navigation) self.init_components(**properties) def prevent_navigation(self, **event_args): c = confirm(\"Are you sure you want to leave this page? Your changes will be lost.\") return not c def save_button_click(self, **event_args): self.routing_context.unregister_blocker(self.prevent_navigation) navigate(path=\"/dashboard\") Note When you register a blocker, if a user navigates to another website, the browser dialogue asking if they want to leave the current page will be shown. Alternatively, you can use the NavigationBlocker context manager. from routing.router import NavigationBlocker class Form(FormTemplate): def __init__(self, **properties): self.init_components(**properties) def run_important_alert(self, **event_args): with NavigationBlocker(warn_before_unload=True): alert(\"Important Alert\", dismissible=False) The above navigation blocker will prevent the user from navigating away from the page while the alert is open. warn_before_unload will show the browser dialogue asking if the user wants to leave the page if they navigate to a new website. By default, this is False .","title":"Blocking Navigation"},{"location":"navigating/blocking-navigation/#alerts","text":"The alert and confirm functions are provided by the routing library. These functions behave similarly to Anvil's default alert and confirm functions, but they will block navigation when dismissible is True , or close the alert when the user navigates to a new page. You can override the default alert and confirm functions by setting the anvil.alert and anvil.confirm attributes in your startup module. # startup.py import anvil from routing import router from . import routes anvil.alert = router.alert anvil.confirm = router.confirm if __name__ == \"__main__\": router.launch()","title":"Alerts"},{"location":"navigating/navigation-components/","text":"Navigation Components \u00b6 A Navigation Component is useful over a Button with a click handler because it supports Ctrl/Cmd clicking a route to open in a new tab and should provide the correct href value for the browser. The routing library provides two Navigation Components: NavLink Anchor Navigation Components by default are subclasses of the Anvil.Link component. However, this can be customised. See Themes for details. NavLink \u00b6 The NavLink component is a link that you will likely use in your main layout's sidebar. The routing library will set the active property on the NavLink to True when the NavLink's properties match the current routing context. If you are using the default NavLink component, then active means it will set its role property to active . If the NavLink component is not the default, then how the active property behaves is determined by the Base class of the NavLink component. Navigation Attributes \u00b6 path The path to navigate to. e.g. /articles/123 or /articles or /articles/:id . The path can be relative ./ . If not set, then the path will be the current path. params The params for the path. e.g. {\"id\": 123} query The query parameters to navigate to. e.g. {\"tab\": \"income\"} . This can be a function that takes the current query parameters as an argument and returns the new query parameters. form_properties The form properties to pass to the form when it is opened. nav_context The nav context for this navigation. hash The hash to navigate to. Tip If you want to set params or query in the designer, you can use the data binding feature of the designer. Active State \u00b6 active The active state of the NavLink. You probably don't want to set this. The routing library will set it to True when the NavLink's properties match the current routing context. exact_path If True , then the path must match exactly. By default, this is False . This means a NavLink with a path of /articles will match the path /articles , /articles/123 and /articles/123/456 . exact_query If True , then the query must inclusively match the current routing context's query. By default, this is False . exact_hash If True , then the hash must match exactly. By default, this is False . You can set most properties in code or in the designer. In the designer, it is recommended to set query properties by using data bindings. Anchor \u00b6 Anchor is a link that you can use inline or as a container for other components. Unlike the NavLink, the Anchor component has no active property.","title":"Navigation Components"},{"location":"navigating/navigation-components/#navigation-components","text":"A Navigation Component is useful over a Button with a click handler because it supports Ctrl/Cmd clicking a route to open in a new tab and should provide the correct href value for the browser. The routing library provides two Navigation Components: NavLink Anchor Navigation Components by default are subclasses of the Anvil.Link component. However, this can be customised. See Themes for details.","title":"Navigation Components"},{"location":"navigating/navigation-components/#navlink","text":"The NavLink component is a link that you will likely use in your main layout's sidebar. The routing library will set the active property on the NavLink to True when the NavLink's properties match the current routing context. If you are using the default NavLink component, then active means it will set its role property to active . If the NavLink component is not the default, then how the active property behaves is determined by the Base class of the NavLink component.","title":"NavLink"},{"location":"navigating/navigation-components/#navigation-attributes","text":"path The path to navigate to. e.g. /articles/123 or /articles or /articles/:id . The path can be relative ./ . If not set, then the path will be the current path. params The params for the path. e.g. {\"id\": 123} query The query parameters to navigate to. e.g. {\"tab\": \"income\"} . This can be a function that takes the current query parameters as an argument and returns the new query parameters. form_properties The form properties to pass to the form when it is opened. nav_context The nav context for this navigation. hash The hash to navigate to. Tip If you want to set params or query in the designer, you can use the data binding feature of the designer.","title":"Navigation Attributes"},{"location":"navigating/navigation-components/#active-state","text":"active The active state of the NavLink. You probably don't want to set this. The routing library will set it to True when the NavLink's properties match the current routing context. exact_path If True , then the path must match exactly. By default, this is False . This means a NavLink with a path of /articles will match the path /articles , /articles/123 and /articles/123/456 . exact_query If True , then the query must inclusively match the current routing context's query. By default, this is False . exact_hash If True , then the hash must match exactly. By default, this is False . You can set most properties in code or in the designer. In the designer, it is recommended to set query properties by using data bindings.","title":"Active State"},{"location":"navigating/navigation-components/#anchor","text":"Anchor is a link that you can use inline or as a container for other components. Unlike the NavLink, the Anchor component has no active property.","title":"Anchor"},{"location":"routes/","text":"Route Class \u00b6 The Route class is used to define routes for your app. When a user navigates to a path, the router will look for a matching route. The router will call anvil.open_form on the matching route's form. # routes.py from routing.router import Route class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" class AboutRoute(Route): path = \"/about\" form = \"Pages.About\" class ContactRoute(Route): path = \"/contact\" form = \"Pages.Contact\" The above code can use the Route.create() method for convenience: # routes.py from routing.router import Route IndexRoute = Route.create(path=\"/\", form=\"Pages.Index\") AboutRoute = Route.create(path=\"/about\", form=\"Pages.About\") ContactRoute = Route.create(path=\"/contact\", form=\"Pages.Contact\") Route Attributes \u00b6 path The path to navigate to. e.g. / , /articles or /articles/:id . form The form to open when the route is matched. e.g. Pages.Index . error_form (optional) The form to open when an error occurs. e.g. Pages.Error . not_found_form (optional) The form to open when the route is not found. e.g. Pages.NotFound . pending_form (optional) The form to open when the data is loading. e.g. Pages.Loading . pending_delay=1 The delay before showing the pending form when the data is loading. pending_min=0.5 The minimum time to show the pending form when the data is loading. cache_form=False Whether to cache the route's form. By default this is False . cache_data=False Whether to cache data. By default this is False . gc_time=30*60 The time in seconds that determines when data is released from the cache for garbage collection. By default this is 30 minutes. When data is released from the cache, any cached forms with the same path and cache_deps will also be released. server_fn (optional str) The server function to call when the route is matched. e.g. \"get_article\" . This server function will be called with the same keyword arguments as the route's load_data method. Note this is optional and equivalent to defining a load_data method that calls the same server function. server_silent=False If True then the server function will be called using anvil.server.call_s . By default this is False . sitemap=True Whether to include this route in the sitemap. By default this is True . Route Methods \u00b6 before_load Called before the route is matched. If it raises a Redirect , navigation is redirected. If it returns a dictionary, its contents are merged into the navigation context ( nav_context ). Note - you may prefer not to override this method, and instead use the @hooks.before_load decorator. See the navigation documentation for practical usage examples. parse_query Should return a dictionary of query parameters. By default this returns the original query parameters. parse_params Should return a dictionary of path parameters. By default this returns the original path parameters. meta Should return a dictionary with the title and description of the page. This will be used to update the meta tags and the title of the page. By default this returns the original title and description. load_data Called when the route is matched. The return value will be available in the data property of the RoutingContext instance. By default this returns None . load_form This method is called with two arguments. The first argument is a form name (e.g. \"Pages.Index\" ) or, if you are using cached forms, the cached form instance. The second argument is the RoutingContext instance. By default this calls anvil.open_form on the form. cache_deps Returns an object, by default the query dictionary (more information in the query section and the RoutingContext section ). This method is part of the process of creating caching keys. When a route needs to cache a form or data (more information in the caching section ), it does so by storing it in a global dictionary under a caching key. This key is composed of the route's path and the return of its cache_deps method at the moment of caching. If, when accessing the same route, its cache_deps method returns something different than when caching first occured, the caching key points to a different place within the cache, usually empty. The router thus understands this as a new route and navigates to it again. Excluding Routes from the Sitemap \u00b6 By default, all routes are included in the sitemap. To exclude a route from the sitemap, set sitemap = False on your Route class: from routing.router import Route class PrivateRoute(Route): path = \"/admin\" form = \"Pages.Admin\" sitemap = False # This route will NOT appear in the sitemap Only routes with sitemap = True (the default) will be included in the sitemap. Setting Meta Tags Per Route \u00b6 To control meta tags for SEO and social sharing, override the meta method on your Route class. Return a dictionary of tags you want to set for that route. You can set any meta tag, including Open Graph and custom tags. Example: from routing.router import Route class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" def meta(self, **loader_args): query = loader_args[\"query\"] # Use query params for dynamic meta title = f\"Article: {query.get('title', 'Untitled')}\" return { \"title\": title, \"description\": f\"Viewing article: {title}\", \"og:image\": \"asset:article_cover.png\", # use asset: prefix or a full URL \"twitter:card\": \"summary_large_image\", # arbitrary tags supported } Fallbacks: og:title and og:description will automatically use title and description if not set. If a meta tag is not set for a route, it falls back to the value present at app load. Server vs Client Meta Tags: title , description , og:title and og:description are set on the server. All other tags are set after page load on the client. og:image and other assets: Use a full URL (e.g., \"https://my-app.anvil.app/_/theme/image.png\" ) Or use an asset from your app: \"asset:image.png\" and it will be resolved to the full URL Not Found Form \u00b6 There are two ways a route can be not found. The first is when the user navigates to a path that does not match any routes. The second is when a user raises a NotFound exception in a route's before_load or load_data method. Not Found Route \u00b6 By definition, if there is no matching route, the router has no route to navigate to. If you want to handle this case, you can define a not found route. from routing.router import Route class NotFoundRoute(Route): form = \"Pages.NotFound\" default_not_found = True The NotFoundRoute will be used when the user navigates to a path that does not match any routes. The path attribute should not be set, since this will be determined based on the path the user navigates to. If no default_not_found attribute is set, then the router will raise a NotFound exception, which will be caught by Anvil's exception handler. Raising a NotFound Exception \u00b6 If you raise a NotFound exception in a route's before_load or load_data method, the router will call the route's load_form method with the route's not found form. from routing.router import Route class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" not_found_form = \"Pages.ArticleNotFound\" def load_data(self, **loader_args): id = loader_args[\"params\"][\"id\"] article = app_tables.articles.get(id=id) if article is None: raise NotFound(f\"No article with id {id}\") return article If a route raises a NotFound exception and there is no not_found_form attribute, the router will raise the exception, which will be caught by Anvil's exception handler. Error Form \u00b6 When a route throws an exception, the router will call anvil.open_form on the matching route's error form. If no error form is defined, the error will be caught by Anvil's exception handler. from routing.router import Route # Either define the error form globally Route.error_form = \"Pages.Error\" # or define the error form per route class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" error_form = \"Pages.Error\" # Pages.Error import anvil class Error(ErrorTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.init_components(**properties) self.routing_context = routing_context self.label.text = ( f\"Error when navigating to {routing_context.path!r}, got {routing_context.error!r}\" ) def form_show(self, **event_args): if anvil.app.environment.name.startswith(\"Debug\"): raise self.routing_context.error Ordering Routes \u00b6 The router will try to match routes in the order they are defined. from routing.router import Route class AuthorsRoute(Route): path = \"/authors\" form = \"Pages.Authors\" class NewAuthorRoute(Route): path = \"/authors/new\" form = \"Pages.NewAuthor\" class AuthorRoute(Route): path = \"/authors/:id\" form = \"Pages.Author\" In the above example, it's important that the NewAuthorRoute comes before the AuthorRoute in the list of routes. This is because /authors/new is a valid path for the AuthorRoute , so the router would successfully match the route and open the form. Server Routes \u00b6 When a user navigates to a URL directly, the router will match routes on the server. When you import your routes in server code, the router will automatically create a server route for each route. # ServerRoutes.py from . import routes Under the hood this will look something like: # ServerRoutes.py from . import routes # pseudo code - for illustration only for route in Routes.__subclasses__(): if route.path is None: continue @anvil.server.route(route.path) def server_route(**params): ... # return a response object that will open the form on the client","title":"Route Class"},{"location":"routes/#route-class","text":"The Route class is used to define routes for your app. When a user navigates to a path, the router will look for a matching route. The router will call anvil.open_form on the matching route's form. # routes.py from routing.router import Route class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" class AboutRoute(Route): path = \"/about\" form = \"Pages.About\" class ContactRoute(Route): path = \"/contact\" form = \"Pages.Contact\" The above code can use the Route.create() method for convenience: # routes.py from routing.router import Route IndexRoute = Route.create(path=\"/\", form=\"Pages.Index\") AboutRoute = Route.create(path=\"/about\", form=\"Pages.About\") ContactRoute = Route.create(path=\"/contact\", form=\"Pages.Contact\")","title":"Route Class"},{"location":"routes/#route-attributes","text":"path The path to navigate to. e.g. / , /articles or /articles/:id . form The form to open when the route is matched. e.g. Pages.Index . error_form (optional) The form to open when an error occurs. e.g. Pages.Error . not_found_form (optional) The form to open when the route is not found. e.g. Pages.NotFound . pending_form (optional) The form to open when the data is loading. e.g. Pages.Loading . pending_delay=1 The delay before showing the pending form when the data is loading. pending_min=0.5 The minimum time to show the pending form when the data is loading. cache_form=False Whether to cache the route's form. By default this is False . cache_data=False Whether to cache data. By default this is False . gc_time=30*60 The time in seconds that determines when data is released from the cache for garbage collection. By default this is 30 minutes. When data is released from the cache, any cached forms with the same path and cache_deps will also be released. server_fn (optional str) The server function to call when the route is matched. e.g. \"get_article\" . This server function will be called with the same keyword arguments as the route's load_data method. Note this is optional and equivalent to defining a load_data method that calls the same server function. server_silent=False If True then the server function will be called using anvil.server.call_s . By default this is False . sitemap=True Whether to include this route in the sitemap. By default this is True .","title":"Route Attributes"},{"location":"routes/#route-methods","text":"before_load Called before the route is matched. If it raises a Redirect , navigation is redirected. If it returns a dictionary, its contents are merged into the navigation context ( nav_context ). Note - you may prefer not to override this method, and instead use the @hooks.before_load decorator. See the navigation documentation for practical usage examples. parse_query Should return a dictionary of query parameters. By default this returns the original query parameters. parse_params Should return a dictionary of path parameters. By default this returns the original path parameters. meta Should return a dictionary with the title and description of the page. This will be used to update the meta tags and the title of the page. By default this returns the original title and description. load_data Called when the route is matched. The return value will be available in the data property of the RoutingContext instance. By default this returns None . load_form This method is called with two arguments. The first argument is a form name (e.g. \"Pages.Index\" ) or, if you are using cached forms, the cached form instance. The second argument is the RoutingContext instance. By default this calls anvil.open_form on the form. cache_deps Returns an object, by default the query dictionary (more information in the query section and the RoutingContext section ). This method is part of the process of creating caching keys. When a route needs to cache a form or data (more information in the caching section ), it does so by storing it in a global dictionary under a caching key. This key is composed of the route's path and the return of its cache_deps method at the moment of caching. If, when accessing the same route, its cache_deps method returns something different than when caching first occured, the caching key points to a different place within the cache, usually empty. The router thus understands this as a new route and navigates to it again.","title":"Route Methods"},{"location":"routes/#excluding-routes-from-the-sitemap","text":"By default, all routes are included in the sitemap. To exclude a route from the sitemap, set sitemap = False on your Route class: from routing.router import Route class PrivateRoute(Route): path = \"/admin\" form = \"Pages.Admin\" sitemap = False # This route will NOT appear in the sitemap Only routes with sitemap = True (the default) will be included in the sitemap.","title":"Excluding Routes from the Sitemap"},{"location":"routes/#setting-meta-tags-per-route","text":"To control meta tags for SEO and social sharing, override the meta method on your Route class. Return a dictionary of tags you want to set for that route. You can set any meta tag, including Open Graph and custom tags. Example: from routing.router import Route class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" def meta(self, **loader_args): query = loader_args[\"query\"] # Use query params for dynamic meta title = f\"Article: {query.get('title', 'Untitled')}\" return { \"title\": title, \"description\": f\"Viewing article: {title}\", \"og:image\": \"asset:article_cover.png\", # use asset: prefix or a full URL \"twitter:card\": \"summary_large_image\", # arbitrary tags supported } Fallbacks: og:title and og:description will automatically use title and description if not set. If a meta tag is not set for a route, it falls back to the value present at app load. Server vs Client Meta Tags: title , description , og:title and og:description are set on the server. All other tags are set after page load on the client. og:image and other assets: Use a full URL (e.g., \"https://my-app.anvil.app/_/theme/image.png\" ) Or use an asset from your app: \"asset:image.png\" and it will be resolved to the full URL","title":"Setting Meta Tags Per Route"},{"location":"routes/#not-found-form","text":"There are two ways a route can be not found. The first is when the user navigates to a path that does not match any routes. The second is when a user raises a NotFound exception in a route's before_load or load_data method.","title":"Not Found Form"},{"location":"routes/#not-found-route","text":"By definition, if there is no matching route, the router has no route to navigate to. If you want to handle this case, you can define a not found route. from routing.router import Route class NotFoundRoute(Route): form = \"Pages.NotFound\" default_not_found = True The NotFoundRoute will be used when the user navigates to a path that does not match any routes. The path attribute should not be set, since this will be determined based on the path the user navigates to. If no default_not_found attribute is set, then the router will raise a NotFound exception, which will be caught by Anvil's exception handler.","title":"Not Found Route"},{"location":"routes/#raising-a-notfound-exception","text":"If you raise a NotFound exception in a route's before_load or load_data method, the router will call the route's load_form method with the route's not found form. from routing.router import Route class ArticleRoute(Route): path = \"/articles/:id\" form = \"Pages.Article\" not_found_form = \"Pages.ArticleNotFound\" def load_data(self, **loader_args): id = loader_args[\"params\"][\"id\"] article = app_tables.articles.get(id=id) if article is None: raise NotFound(f\"No article with id {id}\") return article If a route raises a NotFound exception and there is no not_found_form attribute, the router will raise the exception, which will be caught by Anvil's exception handler.","title":"Raising a NotFound Exception"},{"location":"routes/#error-form","text":"When a route throws an exception, the router will call anvil.open_form on the matching route's error form. If no error form is defined, the error will be caught by Anvil's exception handler. from routing.router import Route # Either define the error form globally Route.error_form = \"Pages.Error\" # or define the error form per route class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" error_form = \"Pages.Error\" # Pages.Error import anvil class Error(ErrorTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.init_components(**properties) self.routing_context = routing_context self.label.text = ( f\"Error when navigating to {routing_context.path!r}, got {routing_context.error!r}\" ) def form_show(self, **event_args): if anvil.app.environment.name.startswith(\"Debug\"): raise self.routing_context.error","title":"Error Form"},{"location":"routes/#ordering-routes","text":"The router will try to match routes in the order they are defined. from routing.router import Route class AuthorsRoute(Route): path = \"/authors\" form = \"Pages.Authors\" class NewAuthorRoute(Route): path = \"/authors/new\" form = \"Pages.NewAuthor\" class AuthorRoute(Route): path = \"/authors/:id\" form = \"Pages.Author\" In the above example, it's important that the NewAuthorRoute comes before the AuthorRoute in the list of routes. This is because /authors/new is a valid path for the AuthorRoute , so the router would successfully match the route and open the form.","title":"Ordering Routes"},{"location":"routes/#server-routes","text":"When a user navigates to a URL directly, the router will match routes on the server. When you import your routes in server code, the router will automatically create a server route for each route. # ServerRoutes.py from . import routes Under the hood this will look something like: # ServerRoutes.py from . import routes # pseudo code - for illustration only for route in Routes.__subclasses__(): if route.path is None: continue @anvil.server.route(route.path) def server_route(**params): ... # return a response object that will open the form on the client","title":"Server Routes"},{"location":"routes/forms/","text":"Forms \u00b6 The Route.load_form method is called when the route is matched. The default implementation will call anvil.open_form on the matching route's form. class Route: def load_form(self, form, routing_context): return anvil.open_form( form, routing_context=routing_context, **routing_context.form_properties ) This method will be called with the form attribute (e.g. \"Pages.Index\" ) or, if you are using cached forms, the cached form instance. open_form Alternative \u00b6 If you are using traditional routing in your Anvil app, you may have a template with a content_panel , and during navigation, you clear the content panel and then add the new form to the panel. If you want to use this style of routing, the routing library provides a TemplateWithContainerRoute class. This class overrides the load_form method. from routing.router import TemplateWithContainerRoute as BaseRoute BaseRoute.template = \"MainTemplate\" class IndexRoute(BaseRoute): path = \"/\" form = \"Pages.Index\" In this case, the load_form method will call anvil.open_form on the template form (if it is not already the current open form). It will then instantiate the form, clear the content_panel of the template, and add the form to the panel. If you are using something other than content_panel , you can set the template_container attribute to the container name. You can also set the template_container_properties attribute to a dictionary of container properties. This is useful if you want to set the full_width_row attribute. from routing.router import TemplateWithContainerRoute as BaseRoute BaseRoute.template = \"MainTemplate\" BaseRoute.template_container = \"content_panel\" BaseRoute.template_container_properties = {\"full_width_row\": True} class IndexRoute(BaseRoute): path = \"/\" form = \"Pages.Index\"","title":"Forms"},{"location":"routes/forms/#forms","text":"The Route.load_form method is called when the route is matched. The default implementation will call anvil.open_form on the matching route's form. class Route: def load_form(self, form, routing_context): return anvil.open_form( form, routing_context=routing_context, **routing_context.form_properties ) This method will be called with the form attribute (e.g. \"Pages.Index\" ) or, if you are using cached forms, the cached form instance.","title":"Forms"},{"location":"routes/forms/#open_form-alternative","text":"If you are using traditional routing in your Anvil app, you may have a template with a content_panel , and during navigation, you clear the content panel and then add the new form to the panel. If you want to use this style of routing, the routing library provides a TemplateWithContainerRoute class. This class overrides the load_form method. from routing.router import TemplateWithContainerRoute as BaseRoute BaseRoute.template = \"MainTemplate\" class IndexRoute(BaseRoute): path = \"/\" form = \"Pages.Index\" In this case, the load_form method will call anvil.open_form on the template form (if it is not already the current open form). It will then instantiate the form, clear the content_panel of the template, and add the form to the panel. If you are using something other than content_panel , you can set the template_container attribute to the container name. You can also set the template_container_properties attribute to a dictionary of container properties. This is useful if you want to set the full_width_row attribute. from routing.router import TemplateWithContainerRoute as BaseRoute BaseRoute.template = \"MainTemplate\" BaseRoute.template_container = \"content_panel\" BaseRoute.template_container_properties = {\"full_width_row\": True} class IndexRoute(BaseRoute): path = \"/\" form = \"Pages.Index\"","title":"open_form Alternative"},{"location":"routes/meta/","text":"Route Meta Method \u00b6 The meta method on a Route class allows you to dynamically set the meta tags for each page, such as the title, description, Open Graph tags, and images. This is useful for SEO, social sharing, and customizing how your app appears in search engines and link previews. Defining Meta Tags \u00b6 Override the meta method in your route class to return a dictionary of meta tags. Standard tags (like title or description ) will be rendered as <meta name=\"...\"> tags, while Open Graph tags (such as og:title or og:image ) will be rendered as <meta property=\"...\"> tags in the HTML. Basic Example \u00b6 from routing import Route class ProductRoute(Route): path = \"/product\" form = \"Pages.Product\" def meta(self, **kwargs): meta_data = {} meta_data['title'] = \"Product Page\" meta_data['description'] = \"Details and specifications for our featured product.\" meta_data['og:title'] = \"Featured Product\" meta_data['og:description'] = \"Learn more about our latest product release.\" meta_data[\"og:image\"] = \"asset:product.jpeg\" # Use a theme asset return meta_data Using get_app_origin() for Absolute URLs \u00b6 If you want to provide an absolute URL for Open Graph images (recommended for social sharing), you can use the get_app_origin() utility: from routing import Route, get_app_origin class AboutRoute(Route): path = \"/about\" form = \"Pages.About\" def meta(self, **kwargs): origin = get_app_origin() meta_data = { 'title': \"About Us\", 'description': \"Information about our company and team.\", 'og:title': \"About Our Company\", 'og:description': \"Discover our mission, values, and team members.\", 'og:image': f\"{origin}/_/theme/about.jpeg\" # Absolute URL } return meta_data Notes \u00b6 All meta tags will be injected into the page as <meta ...> tags, except for title , which will be used for both the <title> tag and a <meta name=\"title\"> tag. You can set any meta tag supported by your app or required by social platforms. Arbitrary meta tags are supported (e.g., Twitter cards twitter:card , twitter:image ). If a meta value starts with asset: , such as asset:foo.jpeg , it will use the corresponding URL for an asset in your app\u2019s Assets or theme assets folder. For absolute URLs, use get_app_origin() to construct the full URL. If a route does not define a particular meta tag, the value from a default or previously set meta tag may be used. For consistency and to avoid unexpected results, it\u2019s recommended to explicitly define all relevant meta tags for each route. Example: Adding Twitter Card Tags \u00b6 class BlogPostRoute(Route): path = \"/blog/post\" form = \"Pages.BlogPost\" def meta(self, **kwargs): meta_data = { 'title': \"Blog Post Title\", 'description': \"A summary of the blog post.\", 'twitter:card': \"summary_large_image\", 'twitter:title': \"Blog Post Title\", 'twitter:description': \"A summary of the blog post.\", 'twitter:image': \"asset:blogpost.jpeg\", # Uses an app asset } return meta_data For more details on available meta tags and advanced usage, see the SEO & Meta Tags guide or the Route class documentation .","title":"Route Meta Method"},{"location":"routes/meta/#route-meta-method","text":"The meta method on a Route class allows you to dynamically set the meta tags for each page, such as the title, description, Open Graph tags, and images. This is useful for SEO, social sharing, and customizing how your app appears in search engines and link previews.","title":"Route Meta Method"},{"location":"routes/meta/#defining-meta-tags","text":"Override the meta method in your route class to return a dictionary of meta tags. Standard tags (like title or description ) will be rendered as <meta name=\"...\"> tags, while Open Graph tags (such as og:title or og:image ) will be rendered as <meta property=\"...\"> tags in the HTML.","title":"Defining Meta Tags"},{"location":"routes/meta/#basic-example","text":"from routing import Route class ProductRoute(Route): path = \"/product\" form = \"Pages.Product\" def meta(self, **kwargs): meta_data = {} meta_data['title'] = \"Product Page\" meta_data['description'] = \"Details and specifications for our featured product.\" meta_data['og:title'] = \"Featured Product\" meta_data['og:description'] = \"Learn more about our latest product release.\" meta_data[\"og:image\"] = \"asset:product.jpeg\" # Use a theme asset return meta_data","title":"Basic Example"},{"location":"routes/meta/#using-get_app_origin-for-absolute-urls","text":"If you want to provide an absolute URL for Open Graph images (recommended for social sharing), you can use the get_app_origin() utility: from routing import Route, get_app_origin class AboutRoute(Route): path = \"/about\" form = \"Pages.About\" def meta(self, **kwargs): origin = get_app_origin() meta_data = { 'title': \"About Us\", 'description': \"Information about our company and team.\", 'og:title': \"About Our Company\", 'og:description': \"Discover our mission, values, and team members.\", 'og:image': f\"{origin}/_/theme/about.jpeg\" # Absolute URL } return meta_data","title":"Using get_app_origin() for Absolute URLs"},{"location":"routes/meta/#notes","text":"All meta tags will be injected into the page as <meta ...> tags, except for title , which will be used for both the <title> tag and a <meta name=\"title\"> tag. You can set any meta tag supported by your app or required by social platforms. Arbitrary meta tags are supported (e.g., Twitter cards twitter:card , twitter:image ). If a meta value starts with asset: , such as asset:foo.jpeg , it will use the corresponding URL for an asset in your app\u2019s Assets or theme assets folder. For absolute URLs, use get_app_origin() to construct the full URL. If a route does not define a particular meta tag, the value from a default or previously set meta tag may be used. For consistency and to avoid unexpected results, it\u2019s recommended to explicitly define all relevant meta tags for each route.","title":"Notes"},{"location":"routes/meta/#example-adding-twitter-card-tags","text":"class BlogPostRoute(Route): path = \"/blog/post\" form = \"Pages.BlogPost\" def meta(self, **kwargs): meta_data = { 'title': \"Blog Post Title\", 'description': \"A summary of the blog post.\", 'twitter:card': \"summary_large_image\", 'twitter:title': \"Blog Post Title\", 'twitter:description': \"A summary of the blog post.\", 'twitter:image': \"asset:blogpost.jpeg\", # Uses an app asset } return meta_data For more details on available meta tags and advanced usage, see the SEO & Meta Tags guide or the Route class documentation .","title":"Example: Adding Twitter Card Tags"},{"location":"routes/params/","text":"Params \u00b6 The path may contain one or more path parameters, denoted by the : character, e.g. /authors/:id . from routing.router import Route class AuthorRoute(Route): path = \"/authors/:id\" form = \"Pages.Author\" When a user navigates to /authors/123 , the routing context will include the path params {\"id\": 123} . from ._anvil_designer import AuthorTemplate from routing.router import RoutingContext class Author(AuthorTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.routing_context = routing_context self.author = anvil.server.call(\"get_author\", routing_context.params.get(\"id\")) self.init_components(**properties) Parsing Params \u00b6 By default, the params are considered JSON-able. e.g. if the path is \"/articles/123\" then the 123 is an integer after calling json.loads . If you want to parse the params into a different type, you can use the parse_params method. class AuthorRoute(Route): path = \"/authors/:id\" form = \"Pages.Author\" def parse_params(self, params): return {\"id\": str(params[\"id\"])} Note If you have numbers in your params, but these should actually be strings, you can convert these to str in your parse_params method. Navigating with Params \u00b6 You can navigate to a route with params by passing the params option to the navigate function. from routing.router import navigate ... def button_click(self, **event_args): navigate(path=\"/authors/:id\", params={\"id\": 123}) Or equivalently with routing NavLink or Anchor components. from ._anvil_designer import RowTemplateTemplate from routing.router import NavLink class RowTemplate(RowTemplateTemplate): def __init__(self, **properties): self.init_components(**properties) self.add_component( NavLink( text=f\"Author {self.item['name']}\", path=\"/authors/:id\", params={\"id\": self.item[\"id\"]}, ) ) Other equivalent ways to navigate include: from routing.router import navigate navigate(path=\"/authors/123\") # the params will still become {\"id\": 123} from routing.router import navigate from ...routes import AuthorRoute navigate(path=AuthorRoute.path, params={\"id\": 123})","title":"Params"},{"location":"routes/params/#params","text":"The path may contain one or more path parameters, denoted by the : character, e.g. /authors/:id . from routing.router import Route class AuthorRoute(Route): path = \"/authors/:id\" form = \"Pages.Author\" When a user navigates to /authors/123 , the routing context will include the path params {\"id\": 123} . from ._anvil_designer import AuthorTemplate from routing.router import RoutingContext class Author(AuthorTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.routing_context = routing_context self.author = anvil.server.call(\"get_author\", routing_context.params.get(\"id\")) self.init_components(**properties)","title":"Params"},{"location":"routes/params/#parsing-params","text":"By default, the params are considered JSON-able. e.g. if the path is \"/articles/123\" then the 123 is an integer after calling json.loads . If you want to parse the params into a different type, you can use the parse_params method. class AuthorRoute(Route): path = \"/authors/:id\" form = \"Pages.Author\" def parse_params(self, params): return {\"id\": str(params[\"id\"])} Note If you have numbers in your params, but these should actually be strings, you can convert these to str in your parse_params method.","title":"Parsing Params"},{"location":"routes/params/#navigating-with-params","text":"You can navigate to a route with params by passing the params option to the navigate function. from routing.router import navigate ... def button_click(self, **event_args): navigate(path=\"/authors/:id\", params={\"id\": 123}) Or equivalently with routing NavLink or Anchor components. from ._anvil_designer import RowTemplateTemplate from routing.router import NavLink class RowTemplate(RowTemplateTemplate): def __init__(self, **properties): self.init_components(**properties) self.add_component( NavLink( text=f\"Author {self.item['name']}\", path=\"/authors/:id\", params={\"id\": self.item[\"id\"]}, ) ) Other equivalent ways to navigate include: from routing.router import navigate navigate(path=\"/authors/123\") # the params will still become {\"id\": 123} from routing.router import navigate from ...routes import AuthorRoute navigate(path=AuthorRoute.path, params={\"id\": 123})","title":"Navigating with Params"},{"location":"routes/query/","text":"Query \u00b6 Query parameters are encoded in a URL following a ? , e.g. /dashboard?tab=sales&page=1 . Query parameters may be referred to by different names, e.g. search, search params, query params, etc. Query parameters are used to make the URL reflect the state of the page. When the page updates in response to user interaction, the URL can be made to change to reflect those changes. Loading a URL with specific query parameters will also load the page in the state indicated by the parameters. For example, if you have a dashboard page with a tab component, you can use the query to encode the active tab. In this routing library, we will refer to query as a dictionary of query parameters. And a query string will be the URL-encoded version of the query . Navigating \u00b6 Let's say you have a dashboard page with a tab component. The tab component has 2 tabs, income and expenses. from ._anvil_designer import DashboardTemplate from routing.router import navigate, RoutingContext class Dashboard(DashboardTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.init_components(**properties) self.routing_context = routing_context routing_context.add_event_handler(\"query_changed\", self.on_query_change) routing_context.raise_init_events() # raises the query_changed event def on_query_change(self, **event_args): query = self.routing_context.query self.tab_1.value = query.get(\"tab\", \"income\") def tab_changed(self, **event_args): tab_value = self.tab_1.value navigate(query={\"tab\": tab_value}) Note that in the tab_changed event handler, we are navigating to the same path, and so, we don't need to include the path in the navigate call. If we want to be explicit, we can use path=\"./\" or path=\"/dashboard\" . By default, if the query parameters change, a new instance of the form will be loaded (even if cache_form is set to True ). See cache_deps below for more details. When the query parameters change, we can listen for the query_changed event and update our page state accordingly. Parsing Query Parameters \u00b6 Since query parameters are encoded in the URL, we may need to decode them. It's also generally a good idea to ignore unknown query parameters and provide sensible defaults if any are missing or incorrect. This provides a better user experience. from routing.router import Route class DashboardRoute(Route): path = \"/dashboard\" form = \"Pages.Dashboard\" def parse_query(self, query): valid_tabs = [\"income\", \"expenses\"] tab = query.get(\"tab\", \"income\") if tab not in valid_tabs: tab = \"income\" return {\"tab\": tab} Using a query validator \u00b6 You can use a validator library. And if the validator has a parse method, it can be used as the parse_query attribute. from anvil_extras import zod as z class DashboardRoute(Route): path = \"/dashboard\" form = \"Pages.Dashboard\" parse_query = z.typed_dict({ \"tab\": z.enum([\"income\", \"expenses\"]).catch(\"income\") }) Query encoding \u00b6 The routing library can encode any JSON-able object as a query parameter. Where a query parameter is a str , int , float , bool or None , this will be flat. e.g. ?foo=bar&baz=1&eggs=true will be decoded as {\"foo\": \"bar\", \"baz\": 1, \"eggs\": True} . Note If you have numbers in your query parameters, but these should actually be strings, you can convert these to str in your parse_query method. For nested, JSON-able objects, i.e. lists and dicts , the routing library will encode the object as a JSON string in the query string. e.g. foo=%5B1%2C+%22a%22%2C+true%5D' will be decoded as {\"foo\": [1, \"a\", true]} . Loading a new instance of a form \u00b6 By default, the routing library will load a new instance of a form when the query parameters change. If you do NOT wish to load a new instance of a form when certain query parameters change, you can override the cache_deps method. This method should return a dict of dependencies, which determine when a form and its data should be loaded from cache . The return value from cache_deps should be JSON-able. from routing.router import Route class DashboardRoute(Route): path = \"/dashboard\" form = \"DashboardForm\" cache_form = True def cache_deps(self, **loader_args): # this form is cached uniquely by the `path` only - there are no `query` dependencies # i.e. if the `tab` changes, we keep the same instance of the form return None For more details on cache_deps , see the data loading section.","title":"Query"},{"location":"routes/query/#query","text":"Query parameters are encoded in a URL following a ? , e.g. /dashboard?tab=sales&page=1 . Query parameters may be referred to by different names, e.g. search, search params, query params, etc. Query parameters are used to make the URL reflect the state of the page. When the page updates in response to user interaction, the URL can be made to change to reflect those changes. Loading a URL with specific query parameters will also load the page in the state indicated by the parameters. For example, if you have a dashboard page with a tab component, you can use the query to encode the active tab. In this routing library, we will refer to query as a dictionary of query parameters. And a query string will be the URL-encoded version of the query .","title":"Query"},{"location":"routes/query/#navigating","text":"Let's say you have a dashboard page with a tab component. The tab component has 2 tabs, income and expenses. from ._anvil_designer import DashboardTemplate from routing.router import navigate, RoutingContext class Dashboard(DashboardTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.init_components(**properties) self.routing_context = routing_context routing_context.add_event_handler(\"query_changed\", self.on_query_change) routing_context.raise_init_events() # raises the query_changed event def on_query_change(self, **event_args): query = self.routing_context.query self.tab_1.value = query.get(\"tab\", \"income\") def tab_changed(self, **event_args): tab_value = self.tab_1.value navigate(query={\"tab\": tab_value}) Note that in the tab_changed event handler, we are navigating to the same path, and so, we don't need to include the path in the navigate call. If we want to be explicit, we can use path=\"./\" or path=\"/dashboard\" . By default, if the query parameters change, a new instance of the form will be loaded (even if cache_form is set to True ). See cache_deps below for more details. When the query parameters change, we can listen for the query_changed event and update our page state accordingly.","title":"Navigating"},{"location":"routes/query/#parsing-query-parameters","text":"Since query parameters are encoded in the URL, we may need to decode them. It's also generally a good idea to ignore unknown query parameters and provide sensible defaults if any are missing or incorrect. This provides a better user experience. from routing.router import Route class DashboardRoute(Route): path = \"/dashboard\" form = \"Pages.Dashboard\" def parse_query(self, query): valid_tabs = [\"income\", \"expenses\"] tab = query.get(\"tab\", \"income\") if tab not in valid_tabs: tab = \"income\" return {\"tab\": tab}","title":"Parsing Query Parameters"},{"location":"routes/query/#using-a-query-validator","text":"You can use a validator library. And if the validator has a parse method, it can be used as the parse_query attribute. from anvil_extras import zod as z class DashboardRoute(Route): path = \"/dashboard\" form = \"Pages.Dashboard\" parse_query = z.typed_dict({ \"tab\": z.enum([\"income\", \"expenses\"]).catch(\"income\") })","title":"Using a query validator"},{"location":"routes/query/#query-encoding","text":"The routing library can encode any JSON-able object as a query parameter. Where a query parameter is a str , int , float , bool or None , this will be flat. e.g. ?foo=bar&baz=1&eggs=true will be decoded as {\"foo\": \"bar\", \"baz\": 1, \"eggs\": True} . Note If you have numbers in your query parameters, but these should actually be strings, you can convert these to str in your parse_query method. For nested, JSON-able objects, i.e. lists and dicts , the routing library will encode the object as a JSON string in the query string. e.g. foo=%5B1%2C+%22a%22%2C+true%5D' will be decoded as {\"foo\": [1, \"a\", true]} .","title":"Query encoding"},{"location":"routes/query/#loading-a-new-instance-of-a-form","text":"By default, the routing library will load a new instance of a form when the query parameters change. If you do NOT wish to load a new instance of a form when certain query parameters change, you can override the cache_deps method. This method should return a dict of dependencies, which determine when a form and its data should be loaded from cache . The return value from cache_deps should be JSON-able. from routing.router import Route class DashboardRoute(Route): path = \"/dashboard\" form = \"DashboardForm\" cache_form = True def cache_deps(self, **loader_args): # this form is cached uniquely by the `path` only - there are no `query` dependencies # i.e. if the `tab` changes, we keep the same instance of the form return None For more details on cache_deps , see the data loading section.","title":"Loading a new instance of a form"},{"location":"routes/redirecting/","text":"Redirecting \u00b6 You can redirect to a different route by raising a Redirect exception in a route's before_load method. from routing.router import Route, Redirect class IndexRoute(Route): path = \"/\" def before_load(self, **loader_args): raise Redirect(path=\"/dashboard\") In the above example, the user will be redirected to the /dashboard route when they navigate to your app. A common use case for redirecting is to ensure that a user is logged in before navigating to a route. from routing.router import Route, Redirect import anvil.users class IndexRoute(Route): path = \"/\" def before_load(self, **loader_args): if anvil.users.get_user(): raise Redirect(path=\"/dashboard\") else: raise Redirect(path=\"/login\") class EnsureUserMixin: def before_load(self, **loader_args): if not anvil.users.get_user(): # Note this will make a server call # so you may want to cache the call to anvil.users.get_user() raise Redirect(path=\"/login\") class DashboardRoute(EnsureUserMixin, Route): path = \"/dashboard\" form = \"Pages.Dashboard\" Note A determined user will be able to bypass the redirect by opening the form directly. Always ensure you check the user is logged in on the server before sending sensitive data to the client.","title":"Redirecting"},{"location":"routes/redirecting/#redirecting","text":"You can redirect to a different route by raising a Redirect exception in a route's before_load method. from routing.router import Route, Redirect class IndexRoute(Route): path = \"/\" def before_load(self, **loader_args): raise Redirect(path=\"/dashboard\") In the above example, the user will be redirected to the /dashboard route when they navigate to your app. A common use case for redirecting is to ensure that a user is logged in before navigating to a route. from routing.router import Route, Redirect import anvil.users class IndexRoute(Route): path = \"/\" def before_load(self, **loader_args): if anvil.users.get_user(): raise Redirect(path=\"/dashboard\") else: raise Redirect(path=\"/login\") class EnsureUserMixin: def before_load(self, **loader_args): if not anvil.users.get_user(): # Note this will make a server call # so you may want to cache the call to anvil.users.get_user() raise Redirect(path=\"/login\") class DashboardRoute(EnsureUserMixin, Route): path = \"/dashboard\" form = \"Pages.Dashboard\" Note A determined user will be able to bypass the redirect by opening the form directly. Always ensure you check the user is logged in on the server before sending sensitive data to the client.","title":"Redirecting"},{"location":"routing-context/","text":"Routing Context \u00b6 A RoutingContext instance is passed to a form when it is instantiated. It provides information about the current route and the current navigation context. from ._anvil_designer import IndexTemplate from routing.router import RoutingContext class IndexTemplate(IndexTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.routing_context = routing_context self.init_components(**properties) Autocompletion Adding the RoutingContext type definition will allow Anvil to show autocompletion for the routing_context property. Properties \u00b6 path The path for the current route. params The parameters for the current route. query The query parameters for the current route. hash The hash for the current route. deps The dependencies dict returned by the cache_deps method. nav_context The navigation context for the current route. This is a dict and can be set by passing a nav_context argument to the navigate method. (Or equivalently by setting the nav_context attribute on a NavLink / Anchor component). form_properties The form properties for the current route. This is a dict and can be set by passing a form_properties argument to the navigate method. (Or equivalently by setting the form_properties attribute on the NavLink / Anchor component). Note the form_properties are passed as keyword arguments when instantiating a form. For more details see the Navigation section. error The error that occurred when loading the form or loading the data. This is particularly useful when displaying error messages in your error form. data The data for the current route. This is the value returned from the load_data method. Events \u00b6 The RoutingContext instance will emit events when the route changes. data_loading Emitted when the data is loading. data_loaded Emitted when the data has been loaded, or when the data has an error. To determine if the data is loaded successfully, check the error property is None . data_error Emitted when the data has an error. query_changed Emitted when the query parameters change. hash_changed Emitted when the hash changes. Methods \u00b6 invalidate(exact=False) Invalidates any cached data or forms for this routing context. If exact is True , then the path and deps must match exactly. By default this is False . If False then any path or deps that are a subset of path and deps arguments will be invalidated. refetch() Invalidates the data for this routing context (with exact=True) and then loads the data again. raise_init_events() Raises the data_loaded , data_loading , data_error , query_changed and hash_changed events. This method is useful during instantiation of the form. First set up your event handlers, then call raise_init_events() .","title":"Routing Context"},{"location":"routing-context/#routing-context","text":"A RoutingContext instance is passed to a form when it is instantiated. It provides information about the current route and the current navigation context. from ._anvil_designer import IndexTemplate from routing.router import RoutingContext class IndexTemplate(IndexTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.routing_context = routing_context self.init_components(**properties) Autocompletion Adding the RoutingContext type definition will allow Anvil to show autocompletion for the routing_context property.","title":"Routing Context"},{"location":"routing-context/#properties","text":"path The path for the current route. params The parameters for the current route. query The query parameters for the current route. hash The hash for the current route. deps The dependencies dict returned by the cache_deps method. nav_context The navigation context for the current route. This is a dict and can be set by passing a nav_context argument to the navigate method. (Or equivalently by setting the nav_context attribute on a NavLink / Anchor component). form_properties The form properties for the current route. This is a dict and can be set by passing a form_properties argument to the navigate method. (Or equivalently by setting the form_properties attribute on the NavLink / Anchor component). Note the form_properties are passed as keyword arguments when instantiating a form. For more details see the Navigation section. error The error that occurred when loading the form or loading the data. This is particularly useful when displaying error messages in your error form. data The data for the current route. This is the value returned from the load_data method.","title":"Properties"},{"location":"routing-context/#events","text":"The RoutingContext instance will emit events when the route changes. data_loading Emitted when the data is loading. data_loaded Emitted when the data has been loaded, or when the data has an error. To determine if the data is loaded successfully, check the error property is None . data_error Emitted when the data has an error. query_changed Emitted when the query parameters change. hash_changed Emitted when the hash changes.","title":"Events"},{"location":"routing-context/#methods","text":"invalidate(exact=False) Invalidates any cached data or forms for this routing context. If exact is True , then the path and deps must match exactly. By default this is False . If False then any path or deps that are a subset of path and deps arguments will be invalidated. refetch() Invalidates the data for this routing context (with exact=True) and then loads the data again. raise_init_events() Raises the data_loaded , data_loading , data_error , query_changed and hash_changed events. This method is useful during instantiation of the form. First set up your event handlers, then call raise_init_events() .","title":"Methods"},{"location":"theme/","text":"Theme \u00b6 When creating a custom theme for your Anvil app, you may want to implement your own components for the NavLink and Anchor base classes. Default NavLink and Anchor Components \u00b6 The default implementations for the NavLink and Anchor base classes are as follows: import anvil class NavLinkBase(anvil.Link): def __init__(self, active=None, **properties): self._props = properties super().__init__(**properties) @property def active(self): return self._props.get(\"active\") @active.setter def active(self, value): self._props[\"active\"] = value self.role = \"selected\" if value else None class AnchorBase(anvil.Link): pass Customising the NavLink and Anchor Components \u00b6 To configure the routing library to use your custom base classes, follow these steps: Create a preload module in your project: # preload module: _preload.py import anvil from ...MyNavLink import MyNavLink from ...MyAnchor import MyAnchor anvil.pluggable_ui.provide( \"MY_PACKAGE_NAME\", {\"routing.NavLink\": MyNavLink, \"routing.Anchor\": MyAnchor} ) Configure the client initialisation module: The client initialisation module runs when the client starts up. As there is currently no way to set this through the Anvil editor, you'll need to modify your anvil.yaml file locally by adding: client_init_module: _preload Note If multiple themes define NavLink and Anchor base classes, the most recently loaded theme's implementations will take precedence. Supported Themes \u00b6 Currently supported themes include: M3","title":"Theme"},{"location":"theme/#theme","text":"When creating a custom theme for your Anvil app, you may want to implement your own components for the NavLink and Anchor base classes.","title":"Theme"},{"location":"theme/#default-navlink-and-anchor-components","text":"The default implementations for the NavLink and Anchor base classes are as follows: import anvil class NavLinkBase(anvil.Link): def __init__(self, active=None, **properties): self._props = properties super().__init__(**properties) @property def active(self): return self._props.get(\"active\") @active.setter def active(self, value): self._props[\"active\"] = value self.role = \"selected\" if value else None class AnchorBase(anvil.Link): pass","title":"Default NavLink and Anchor Components"},{"location":"theme/#customising-the-navlink-and-anchor-components","text":"To configure the routing library to use your custom base classes, follow these steps: Create a preload module in your project: # preload module: _preload.py import anvil from ...MyNavLink import MyNavLink from ...MyAnchor import MyAnchor anvil.pluggable_ui.provide( \"MY_PACKAGE_NAME\", {\"routing.NavLink\": MyNavLink, \"routing.Anchor\": MyAnchor} ) Configure the client initialisation module: The client initialisation module runs when the client starts up. As there is currently no way to set this through the Anvil editor, you'll need to modify your anvil.yaml file locally by adding: client_init_module: _preload Note If multiple themes define NavLink and Anchor base classes, the most recently loaded theme's implementations will take precedence.","title":"Customising the NavLink and Anchor Components"},{"location":"theme/#supported-themes","text":"Currently supported themes include: M3","title":"Supported Themes"}]}