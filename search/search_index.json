{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 This documentation provides an overview of the API for the routing library. Installation \u00b6 You can use this library as a third party Anvil dependency with the code ABC123 . Quick Start \u00b6 Clone the following Anvil app: https://anvil.works/app/ABC123 Or create a new app from Anvil app The client code structure should look like this: - Layouts (Package) - Main (Form - ensure you tick \"Use as layout\") - Pages (Package) - Index (Form choosing Layouts.Main as the layout) - About (Form choosing Layouts.Main as the layout) - Contact (Form choosing Layouts.Main as the layout) - routes (Module) - startup (Module) # startup.py from routing.router import launch from .import routes if __name__ == \"__main__\": launch() # routes.py from routing.router import Route class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" class AboutRoute(Route): path = \"/about\" form = \"Pages.About\" class ContactRoute(Route): path = \"/contact\" form = \"Pages.Contact\" Inside your Server code, create a server module that imports the routes module. # ServerRoutes.py from . import routes You should now be able to run the app and navigate to different pages by changing the URL in the browser. Initializing the Router \u00b6 How to initialize the router. Defining Routes \u00b6 How to define routes. Handling Routes \u00b6 How to handle and process routes. API Reference \u00b6 Route Class \u00b6 Details about the Route class and its methods, if applicable. Navigation \u00b6 Details about navigating. Examples \u00b6 Some basic examples of how to use the routing library.","title":"Overview"},{"location":"#overview","text":"This documentation provides an overview of the API for the routing library.","title":"Overview"},{"location":"#installation","text":"You can use this library as a third party Anvil dependency with the code ABC123 .","title":"Installation"},{"location":"#quick-start","text":"Clone the following Anvil app: https://anvil.works/app/ABC123 Or create a new app from Anvil app The client code structure should look like this: - Layouts (Package) - Main (Form - ensure you tick \"Use as layout\") - Pages (Package) - Index (Form choosing Layouts.Main as the layout) - About (Form choosing Layouts.Main as the layout) - Contact (Form choosing Layouts.Main as the layout) - routes (Module) - startup (Module) # startup.py from routing.router import launch from .import routes if __name__ == \"__main__\": launch() # routes.py from routing.router import Route class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" class AboutRoute(Route): path = \"/about\" form = \"Pages.About\" class ContactRoute(Route): path = \"/contact\" form = \"Pages.Contact\" Inside your Server code, create a server module that imports the routes module. # ServerRoutes.py from . import routes You should now be able to run the app and navigate to different pages by changing the URL in the browser.","title":"Quick Start"},{"location":"#initializing-the-router","text":"How to initialize the router.","title":"Initializing the Router"},{"location":"#defining-routes","text":"How to define routes.","title":"Defining Routes"},{"location":"#handling-routes","text":"How to handle and process routes.","title":"Handling Routes"},{"location":"#api-reference","text":"","title":"API Reference"},{"location":"#route-class","text":"Details about the Route class and its methods, if applicable.","title":"Route Class"},{"location":"#navigation","text":"Details about navigating.","title":"Navigation"},{"location":"#examples","text":"Some basic examples of how to use the routing library.","title":"Examples"},{"location":"quick-start/","text":"Quick Start \u00b6 From a Clone \u00b6 Clone the following Anvil app: https://anvil.works/app/ABC123 From a New App \u00b6 Create a new app. Client Code Structure \u00b6 The client code structure should look like this: - Layouts (Package) - Main (Form - ensure you tick \"Use as layout\") - Pages (Package) - Index (Form choosing Layouts.Main as the layout) - About (Form choosing Layouts.Main as the layout) - Contact (Form choosing Layouts.Main as the layout) - routes (Module) - startup (Module) Startup Module \u00b6 # startup.py from routing.router import launch from .import routes if __name__ == \"__main__\": launch() Routes Module \u00b6 # routes.py from routing.router import Route class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" class AboutRoute(Route): path = \"/about\" form = \"Pages.About\" class ContactRoute(Route): path = \"/contact\" form = \"Pages.Contact\" Server Routes Module \u00b6 Inside your Server code, create a server module that imports the routes module. # ServerRoutes.py from . import routes You should now be able to run the app and navigate to different pages by changing the URL in the browser. Navigation \u00b6 In Layouts.Main , include a SideBar and add 3 NavLink components. (The NavLink component should come from the routing library) In the designer, set the text and path properties of the NavLink . The first NavLink should have the text=\"Home\" and the path=\"/\" . The second NavLink should have the text=\"About\" and the path=\"/about\" . The third NavLink should have the text=\"Contact\" and the path=\"/contact\" . Add a title slot to the Layouts.Main form. And inside Pages.Index , add a label component to the title slot with the text property set to \"Home\" . Do the same for Pages.About and Pages.Contact . You should now be able to navigate using the side bar nav links. As you navigate to the different pages, you should see that the title of the page changes.","title":"Quick Start"},{"location":"quick-start/#quick-start","text":"","title":"Quick Start"},{"location":"quick-start/#from-a-clone","text":"Clone the following Anvil app: https://anvil.works/app/ABC123","title":"From a Clone"},{"location":"quick-start/#from-a-new-app","text":"Create a new app.","title":"From a New App"},{"location":"quick-start/#client-code-structure","text":"The client code structure should look like this: - Layouts (Package) - Main (Form - ensure you tick \"Use as layout\") - Pages (Package) - Index (Form choosing Layouts.Main as the layout) - About (Form choosing Layouts.Main as the layout) - Contact (Form choosing Layouts.Main as the layout) - routes (Module) - startup (Module)","title":"Client Code Structure"},{"location":"quick-start/#startup-module","text":"# startup.py from routing.router import launch from .import routes if __name__ == \"__main__\": launch()","title":"Startup Module"},{"location":"quick-start/#routes-module","text":"# routes.py from routing.router import Route class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" class AboutRoute(Route): path = \"/about\" form = \"Pages.About\" class ContactRoute(Route): path = \"/contact\" form = \"Pages.Contact\"","title":"Routes Module"},{"location":"quick-start/#server-routes-module","text":"Inside your Server code, create a server module that imports the routes module. # ServerRoutes.py from . import routes You should now be able to run the app and navigate to different pages by changing the URL in the browser.","title":"Server Routes Module"},{"location":"quick-start/#navigation","text":"In Layouts.Main , include a SideBar and add 3 NavLink components. (The NavLink component should come from the routing library) In the designer, set the text and path properties of the NavLink . The first NavLink should have the text=\"Home\" and the path=\"/\" . The second NavLink should have the text=\"About\" and the path=\"/about\" . The third NavLink should have the text=\"Contact\" and the path=\"/contact\" . Add a title slot to the Layouts.Main form. And inside Pages.Index , add a label component to the title slot with the text property set to \"Home\" . Do the same for Pages.About and Pages.Contact . You should now be able to navigate using the side bar nav links. As you navigate to the different pages, you should see that the title of the page changes.","title":"Navigation"},{"location":"data-loading/","text":"","title":"Index"},{"location":"migrating/","text":"","title":"Index"},{"location":"navigating/","text":"Navigation \u00b6 There are two ways to navigate. The first is with the navigate and the second is with a navigation component . Navigating with navigate \u00b6 The navigate function is a function that you will likely call from a click handler. Call Signatures \u00b6 navigate(*, path=None, params=None, query=None, hash=None, replace=False, nav_context=None, form_properties=None) use keyword arguments only navigate(path, **kws) the first argument can be the path navigate(url, **kws) the first argument ca be a url navigate(routing_context, **kws) the first argument can be a routing context Arguments \u00b6 path The path to navigate to. e.g. /articles/123 or /articles or /articles/:id . The path can be relative ./ . If not set then the path will be the current path. params The params for the path. e.g. {\"id\": 123} query The query parameters to navigate to. e.g. {\"tab\": \"income\"} hash The hash to navigate to. replace If True then the current url will be replaced with the new url (default is False ). nav_context The nav context to for this navigation. form_properties The form properties to pass to the form when it is opened. Use of form_properties \u00b6 The form_properties is a dictionary that is passed to the open_form function. A common use case is to pass the form's item property. Note that if you are relying on form_properties you will always need to account for form_properties being an empty dictionary, when the user navigates by changing the url directly. from routing import router class RowTemplate(RowTemplateTemplate): def __init__(self, **properties): self.init_components(**properties) def button_click(self, **event_args): router.navigate(path=\"/articles/:id\", params={\"id\": self.item[\"id\"]}, form_properties={\"item\": self.item}) And then in the /articles/:id route: from routing import router class ArticleForm(ArticleFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context if properties.get(\"item\") is None: # the user navigated directly to the form by changing the url properties[\"item\"] = anvil.server.call(\"get_article\", routing_context.params[\"id\"]) self.init_components(**properties) Use of nav_context \u00b6 The nav_context is a dictionary that is passed to the navigate function. A use case for this is to pass the previous routing context to the next routing context. This is useful when you want to navigate to a new route, but you want to preserve the previous route's data. Particularly if the previous route uses query parameters that determine the state of the form. from routing import router def on_button_click(self, **event_args): current_context = router.get_routing_context() router.navigate(path=\"/foo\", nav_context={\"prev_context\": current_context}) And then in the /foo route: from routing import router class FooForm(FooFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context self.init_components(**properties) def cancel_button_click(self, **event_args): prev_context = self.routing_context.nav_context.get(\"prev_context\") if prev_context is not None: router.navigate(prev_context) else: # no nav-context - the user navigated directly to the form by changing the url router.navigate(path=\"/\")","title":"Navigation"},{"location":"navigating/#navigation","text":"There are two ways to navigate. The first is with the navigate and the second is with a navigation component .","title":"Navigation"},{"location":"navigating/#navigating-with-navigate","text":"The navigate function is a function that you will likely call from a click handler.","title":"Navigating with navigate"},{"location":"navigating/#call-signatures","text":"navigate(*, path=None, params=None, query=None, hash=None, replace=False, nav_context=None, form_properties=None) use keyword arguments only navigate(path, **kws) the first argument can be the path navigate(url, **kws) the first argument ca be a url navigate(routing_context, **kws) the first argument can be a routing context","title":"Call Signatures"},{"location":"navigating/#arguments","text":"path The path to navigate to. e.g. /articles/123 or /articles or /articles/:id . The path can be relative ./ . If not set then the path will be the current path. params The params for the path. e.g. {\"id\": 123} query The query parameters to navigate to. e.g. {\"tab\": \"income\"} hash The hash to navigate to. replace If True then the current url will be replaced with the new url (default is False ). nav_context The nav context to for this navigation. form_properties The form properties to pass to the form when it is opened.","title":"Arguments"},{"location":"navigating/#use-of-form_properties","text":"The form_properties is a dictionary that is passed to the open_form function. A common use case is to pass the form's item property. Note that if you are relying on form_properties you will always need to account for form_properties being an empty dictionary, when the user navigates by changing the url directly. from routing import router class RowTemplate(RowTemplateTemplate): def __init__(self, **properties): self.init_components(**properties) def button_click(self, **event_args): router.navigate(path=\"/articles/:id\", params={\"id\": self.item[\"id\"]}, form_properties={\"item\": self.item}) And then in the /articles/:id route: from routing import router class ArticleForm(ArticleFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context if properties.get(\"item\") is None: # the user navigated directly to the form by changing the url properties[\"item\"] = anvil.server.call(\"get_article\", routing_context.params[\"id\"]) self.init_components(**properties)","title":"Use of form_properties"},{"location":"navigating/#use-of-nav_context","text":"The nav_context is a dictionary that is passed to the navigate function. A use case for this is to pass the previous routing context to the next routing context. This is useful when you want to navigate to a new route, but you want to preserve the previous route's data. Particularly if the previous route uses query parameters that determine the state of the form. from routing import router def on_button_click(self, **event_args): current_context = router.get_routing_context() router.navigate(path=\"/foo\", nav_context={\"prev_context\": current_context}) And then in the /foo route: from routing import router class FooForm(FooFormTemplate): def __init__(self, routing_context: router.RoutingContext, **properties): self.routing_context = routing_context self.init_components(**properties) def cancel_button_click(self, **event_args): prev_context = self.routing_context.nav_context.get(\"prev_context\") if prev_context is not None: router.navigate(prev_context) else: # no nav-context - the user navigated directly to the form by changing the url router.navigate(path=\"/\")","title":"Use of nav_context"},{"location":"navigating/Navigation%20Components/","text":"Navigation Components \u00b6 A Navigation Component is useful over a Button with a click handler because it supports ctr/cmd clicking a route to open in a new tab, and should provide the correct href value for the browser. The routing library provides two Navigation Components: NavLink Anchor Navigation Components by default are subclasses of the Anvil.Link component. But this can be customized. See Themes for details. NavLink \u00b6 The NavLink component is a link that you will likely use in your main layout's sidebar. The routing library will set the active property on the NavLink to True when the NavLink's properties match the current routing context. If you are using the default NavLink component, then active means it will set it's role property to selected . If the NavLink component is not the default, then how the active property behaves is determined by the Base class of the NavLink component. Navigation Attributes \u00b6 path The path to navigate to. e.g. /articles/123 or /articles or /articles/:id . The path can be relative ./ . If not set then the path will be the current path. params The params for the path. e.g. {\"id\": 123} query The query parameters to navigate to. e.g. {\"tab\": \"income\"} form_properties The form properties to pass to the form when it is opened. nav_context The nav context to for this navigation. hash The hash to navigate to. Tip If you want to set params or query in the designer, you can use the data binding feature of the designer. Active State \u00b6 active The active state of the NavLink. You probably don't want to set this. The routing library will set it to True when the NavLink's properties match the current routing context. exact_path If True then the path must match exactly. By default this is False . Which means a NavLink with a path of /articles will match the path /articles , /articles/123 and /articles/123/456 . exact_query If True then the query must match exactly. By default this is False . exact_hash If True then the hash must match exactly. By default this is False . You can set most properties in code or in the designer. In the designer, it is recommended to set query properties by using data bindings. Anchor \u00b6 Anchor is a link that you can use inline, or use as a container for other components. Unlike the NavLink, the Anchor component has no active property.","title":"Navigation Components"},{"location":"navigating/Navigation%20Components/#navigation-components","text":"A Navigation Component is useful over a Button with a click handler because it supports ctr/cmd clicking a route to open in a new tab, and should provide the correct href value for the browser. The routing library provides two Navigation Components: NavLink Anchor Navigation Components by default are subclasses of the Anvil.Link component. But this can be customized. See Themes for details.","title":"Navigation Components"},{"location":"navigating/Navigation%20Components/#navlink","text":"The NavLink component is a link that you will likely use in your main layout's sidebar. The routing library will set the active property on the NavLink to True when the NavLink's properties match the current routing context. If you are using the default NavLink component, then active means it will set it's role property to selected . If the NavLink component is not the default, then how the active property behaves is determined by the Base class of the NavLink component.","title":"NavLink"},{"location":"navigating/Navigation%20Components/#navigation-attributes","text":"path The path to navigate to. e.g. /articles/123 or /articles or /articles/:id . The path can be relative ./ . If not set then the path will be the current path. params The params for the path. e.g. {\"id\": 123} query The query parameters to navigate to. e.g. {\"tab\": \"income\"} form_properties The form properties to pass to the form when it is opened. nav_context The nav context to for this navigation. hash The hash to navigate to. Tip If you want to set params or query in the designer, you can use the data binding feature of the designer.","title":"Navigation Attributes"},{"location":"navigating/Navigation%20Components/#active-state","text":"active The active state of the NavLink. You probably don't want to set this. The routing library will set it to True when the NavLink's properties match the current routing context. exact_path If True then the path must match exactly. By default this is False . Which means a NavLink with a path of /articles will match the path /articles , /articles/123 and /articles/123/456 . exact_query If True then the query must match exactly. By default this is False . exact_hash If True then the hash must match exactly. By default this is False . You can set most properties in code or in the designer. In the designer, it is recommended to set query properties by using data bindings.","title":"Active State"},{"location":"navigating/Navigation%20Components/#anchor","text":"Anchor is a link that you can use inline, or use as a container for other components. Unlike the NavLink, the Anchor component has no active property.","title":"Anchor"},{"location":"routes/","text":"Route Class \u00b6 The Route class is used to define routes for your app. When a user navigates to a path, the router will look for a matching route. The router will call anvil.open_form on the matching route's form. # routes.py from routing.router import Route class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" class AboutRoute(Route): path = \"/about\" form = \"Pages.About\" class ContactRoute(Route): path = \"/contact\" form = \"Pages.Contact\" The above code can use the Route.create() method for convenience: # routes.py from routing.router import Route IndexRoute = Route.create(path=\"/\", form=\"Pages.Index\") AboutRoute = Route.create(path=\"/about\", form=\"Pages.About\") ContactRoute = Route.create(path=\"/contact\", form=\"Pages.Contact\") Form instantiation \u00b6 When a form is instantiated, the router will pass a routing_context property to the form. This property holds information about the current route and the current navigation context. from ._anvil_designer import IndexTemplate from routing.router import RoutingContext class IndexTemplate(IndexTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.routing_context = routing_context self.init_components(**properties) Adding the RoutingContext type definition will allow anvil to show autocompletion for the routing_context property. Caching Forms \u00b6 By default, the open_form will NOT cache the form. This means a new instance of the form will be created every time the user navigates to the route. If you want to cache the form, you can set the cache_form attribute to True on the route. You can set this attribute on specific routes. class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" cache_form = True Or you can set this attribute for all routes by setting the cache_form attribute on the Route class. from routing.router import Route # override the default behavior for all routes Route.cache_form = True class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" Not Found Form \u00b6 If a route is not found, the router will call anvil.open_form on the matching route's not found form. If no not found form is defined, the router will raise a NotFound exception, which will be caught by Anvil's exception handler. from routing.router import Route # you probably want to define a default not found form Route.not_found_form = \"Pages.NotFound\" Error Form \u00b6 When a route throws an exception, the router will call anvil.open_form on the matching route's error form. If no error form is defined, the error will be caught by Anvil's exception handler. from routing.router import Route # Either define the error form globally Route.error_form = \"Pages.Error\" # or define the error form per route class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" error_form = \"Pages.Error\" Ordering Routes \u00b6 The router will try to match routes in the order they are defined. from routing.router import Route class AuthorsRoute(Route): path = \"/authors\" form = \"Pages.Authors\" class NewAuthorRoute(Route): path = \"/authors/new\" form = \"Pages.NewAuthor\" class AuthorRoute(Route): path = \"/authors/:id\" form = \"Pages.Author\" In the above example, it's important that the NewAuthorRoute comes before the AuthorRoute in the list of routes. This is because /authors/new is a valid path for the AuthorRoute , so the router would successfully match the route and open the form. Server Routes \u00b6 When a user navigates to a url directly, the router will match routes on the server. When you import your routes in server code, the router will automatically create a server route for each route. # ServerRoutes.py from . import routes Under the hood this will look something like: # ServerRoutes.py from . import routes # pseudo code - for illustration only for route in Routes.__subclasses__(): if route.path is None: continue @anvil.server.route(route.path) def server_route(**params): ... # return a response object that will open the form on the client","title":"Route Class"},{"location":"routes/#route-class","text":"The Route class is used to define routes for your app. When a user navigates to a path, the router will look for a matching route. The router will call anvil.open_form on the matching route's form. # routes.py from routing.router import Route class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" class AboutRoute(Route): path = \"/about\" form = \"Pages.About\" class ContactRoute(Route): path = \"/contact\" form = \"Pages.Contact\" The above code can use the Route.create() method for convenience: # routes.py from routing.router import Route IndexRoute = Route.create(path=\"/\", form=\"Pages.Index\") AboutRoute = Route.create(path=\"/about\", form=\"Pages.About\") ContactRoute = Route.create(path=\"/contact\", form=\"Pages.Contact\")","title":"Route Class"},{"location":"routes/#form-instantiation","text":"When a form is instantiated, the router will pass a routing_context property to the form. This property holds information about the current route and the current navigation context. from ._anvil_designer import IndexTemplate from routing.router import RoutingContext class IndexTemplate(IndexTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.routing_context = routing_context self.init_components(**properties) Adding the RoutingContext type definition will allow anvil to show autocompletion for the routing_context property.","title":"Form instantiation"},{"location":"routes/#caching-forms","text":"By default, the open_form will NOT cache the form. This means a new instance of the form will be created every time the user navigates to the route. If you want to cache the form, you can set the cache_form attribute to True on the route. You can set this attribute on specific routes. class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" cache_form = True Or you can set this attribute for all routes by setting the cache_form attribute on the Route class. from routing.router import Route # override the default behavior for all routes Route.cache_form = True class IndexRoute(Route): path = \"/\" form = \"Pages.Index\"","title":"Caching Forms"},{"location":"routes/#not-found-form","text":"If a route is not found, the router will call anvil.open_form on the matching route's not found form. If no not found form is defined, the router will raise a NotFound exception, which will be caught by Anvil's exception handler. from routing.router import Route # you probably want to define a default not found form Route.not_found_form = \"Pages.NotFound\"","title":"Not Found Form"},{"location":"routes/#error-form","text":"When a route throws an exception, the router will call anvil.open_form on the matching route's error form. If no error form is defined, the error will be caught by Anvil's exception handler. from routing.router import Route # Either define the error form globally Route.error_form = \"Pages.Error\" # or define the error form per route class IndexRoute(Route): path = \"/\" form = \"Pages.Index\" error_form = \"Pages.Error\"","title":"Error Form"},{"location":"routes/#ordering-routes","text":"The router will try to match routes in the order they are defined. from routing.router import Route class AuthorsRoute(Route): path = \"/authors\" form = \"Pages.Authors\" class NewAuthorRoute(Route): path = \"/authors/new\" form = \"Pages.NewAuthor\" class AuthorRoute(Route): path = \"/authors/:id\" form = \"Pages.Author\" In the above example, it's important that the NewAuthorRoute comes before the AuthorRoute in the list of routes. This is because /authors/new is a valid path for the AuthorRoute , so the router would successfully match the route and open the form.","title":"Ordering Routes"},{"location":"routes/#server-routes","text":"When a user navigates to a url directly, the router will match routes on the server. When you import your routes in server code, the router will automatically create a server route for each route. # ServerRoutes.py from . import routes Under the hood this will look something like: # ServerRoutes.py from . import routes # pseudo code - for illustration only for route in Routes.__subclasses__(): if route.path is None: continue @anvil.server.route(route.path) def server_route(**params): ... # return a response object that will open the form on the client","title":"Server Routes"},{"location":"routes/data/","text":"","title":"Data"},{"location":"routes/params/","text":"Params \u00b6 The path may contain one or more path parameters, denoted by the : character, e.g. /authors/:id . from routing.router import Route class AuthorRoute(Route): path = \"/authors/:id\" form = \"Pages.Author\" When a user navigates to /authors/123 , the routing context will include the path params {\"id\": \"123\"} . from ._anvil_designer import AuthorTemplate from routing.router import RoutingContext class Author(AuthorTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.routing_context = routing_context self.author = anvil.server.call(\"get_author\", routing_context.params.get(\"id\")) self.init_components(**properties) Parsing Params \u00b6 By default, the params are always strings. If you want to parse the params into a different type, you can use the parse_params method. class AuthorRoute(Route): path = \"/authors/:id\" form = \"Pages.Author\" def parse_params(self, params): return {\"id\": int(params[\"id\"])} Navigating with Params \u00b6 You can navigate to a route with params by passing the params option to the navigate function. from routing.router import navigate ... def button_click(self, **event_args): navigate(path=\"/authors/:id\", params={\"id\": 123}) Or equivalently with routing NavLink or Anchor components. from ._anvil_designer import RowTemplateTemplate from routing.router import NavLink class RowTemplate(RowTemplateTemplate): def __init__(self, **properties): self.init_components(**properties) self.add_component( NavLink( text=f\"Author {self.item['name']}\", path=\"/authors/:id\", params={\"id\": self.item[\"id\"]}, ) ) Other equivalent ways to navigate include: from routing.router import navigate navigate(path=\"/authors/123\") # the params will still become {\"id\": \"123\"} from routing.router import navigate from ...routes import AuthorRoute navigate(path=AuthorRoute.path, params={\"id\": 123}) from routing.router import navigate from ...routes import AuthorRoute navigate(AuthorRoute, params={\"id\": 123})","title":"Params"},{"location":"routes/params/#params","text":"The path may contain one or more path parameters, denoted by the : character, e.g. /authors/:id . from routing.router import Route class AuthorRoute(Route): path = \"/authors/:id\" form = \"Pages.Author\" When a user navigates to /authors/123 , the routing context will include the path params {\"id\": \"123\"} . from ._anvil_designer import AuthorTemplate from routing.router import RoutingContext class Author(AuthorTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.routing_context = routing_context self.author = anvil.server.call(\"get_author\", routing_context.params.get(\"id\")) self.init_components(**properties)","title":"Params"},{"location":"routes/params/#parsing-params","text":"By default, the params are always strings. If you want to parse the params into a different type, you can use the parse_params method. class AuthorRoute(Route): path = \"/authors/:id\" form = \"Pages.Author\" def parse_params(self, params): return {\"id\": int(params[\"id\"])}","title":"Parsing Params"},{"location":"routes/params/#navigating-with-params","text":"You can navigate to a route with params by passing the params option to the navigate function. from routing.router import navigate ... def button_click(self, **event_args): navigate(path=\"/authors/:id\", params={\"id\": 123}) Or equivalently with routing NavLink or Anchor components. from ._anvil_designer import RowTemplateTemplate from routing.router import NavLink class RowTemplate(RowTemplateTemplate): def __init__(self, **properties): self.init_components(**properties) self.add_component( NavLink( text=f\"Author {self.item['name']}\", path=\"/authors/:id\", params={\"id\": self.item[\"id\"]}, ) ) Other equivalent ways to navigate include: from routing.router import navigate navigate(path=\"/authors/123\") # the params will still become {\"id\": \"123\"} from routing.router import navigate from ...routes import AuthorRoute navigate(path=AuthorRoute.path, params={\"id\": 123}) from routing.router import navigate from ...routes import AuthorRoute navigate(AuthorRoute, params={\"id\": 123})","title":"Navigating with Params"},{"location":"routes/query/","text":"Query \u00b6 Query parameters are encoded in a url following a ? , e.g. /dashboard?tab=sales&page=1 . Query parameters may be referred to by different names, e.g. search, search params, query params, etc. In this routing library we will refer to query as a dictionary of query parameters. And a query string will be the url encoded version of the query . The query is best used to encode the state of the page. For example, if you have a dashboard page with a tab component, you can use the query to encode the active tab. Navigating \u00b6 Let's say you have a dashboard page with a tab component. The tab component has 2 tabs, income and expenses. from ._anvil_designer import DashboardTemplate from routing.router import navigate, RoutingContext class Dashboard(DashboardTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.routing_context = routing_context self.routing_context.add_event_handler(\"query_changed\", self.on_query_change) self.set_tab_from_query() self.init_components(**properties) def set_tab_from_query(self, **event_args): query = self.routing_context.query self.tab_1.value = query.get(\"tab\", \"income\") def tab_changed(self, **event_args): tab_value = self.tab_1.value navigate(query={\"tab\": tab_value}) Note that in the tab_changed event handler, we are navigating to the same page, and so, we don't need to include the path in the navigate call. If we want to be explicit, we can use path=\"./\" or path=\"/dashboard\" . By default, if the query parameters change, the page will not be reloaded. When the query parameters change, we can listen for the query_changed event and update our page state accordingly. Parsing Query Parameters \u00b6 Since query parameters are encoded in the url, we may need to decode them. It's also generally a good idea to ignore unknown query parameters and provide sensible defaults if any are missing, or incorrect. This provides a better user experience. from routing.router import Route class DashboardRoute(Route): path = \"/dashboard\" form = \"Pages.Dashboard\" def parse_query(self, query): valid_tabs = [\"income\", \"expenses\"] tab = query.get(\"tab\", \"income\") if tab not in valid_tabs: tab = \"income\" return {\"tab\": tab} Using a query validator \u00b6 You can use a validator library. And if the validator has a parse method, it can be used as the parse_query attribute. from anvil_extras import zod as z class DashboardRoute(Route): path = \"/dashboard\" form = \"Pages.Dashboard\" parse_query = z.typed_dict({ \"tab\": z.enum([\"income\", \"expenses\"]).catch(\"income\") }) Query encoding \u00b6 The routing library can encode any json-able object as a query parameter. Where a query parameter is a str , int , float , bool or None this will be flat. e.g. ?foo=bar&baz=1&eggs=true will be decoded as {\"foo\": \"bar\", \"baz\": 1, \"eggs\": True} . Note If you have numbers in your query parameters, but these should actually be strings, you can convert these to str in your parse_query method. For nested, json-able objects, i.e. lists and dicts , the routing library will encode the object as a json string. Loading a new instance of a form \u00b6 By default the routing library will not load a new instance of a form when the query parameters change. If you wish to load a new instance of a form when certain query parameters change, you can use the loader_deps method. This method should return a dict of dependencies, which determine when a form and it's data should be loaded. The return value from loader_deps should be json-able. from routing.router import Route class DashboardRoute(Route): path = \"/dashboard\" form = \"DashboardForm\" def loader_deps(self, **loader_args): # this ensures that whenever the `tab` changes a new instance of the form is loaded query = loader_args[\"query\"] return {\"tab\": query[\"tab\"]} For more details on loader_deps see the data loading section.","title":"Query"},{"location":"routes/query/#query","text":"Query parameters are encoded in a url following a ? , e.g. /dashboard?tab=sales&page=1 . Query parameters may be referred to by different names, e.g. search, search params, query params, etc. In this routing library we will refer to query as a dictionary of query parameters. And a query string will be the url encoded version of the query . The query is best used to encode the state of the page. For example, if you have a dashboard page with a tab component, you can use the query to encode the active tab.","title":"Query"},{"location":"routes/query/#navigating","text":"Let's say you have a dashboard page with a tab component. The tab component has 2 tabs, income and expenses. from ._anvil_designer import DashboardTemplate from routing.router import navigate, RoutingContext class Dashboard(DashboardTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.routing_context = routing_context self.routing_context.add_event_handler(\"query_changed\", self.on_query_change) self.set_tab_from_query() self.init_components(**properties) def set_tab_from_query(self, **event_args): query = self.routing_context.query self.tab_1.value = query.get(\"tab\", \"income\") def tab_changed(self, **event_args): tab_value = self.tab_1.value navigate(query={\"tab\": tab_value}) Note that in the tab_changed event handler, we are navigating to the same page, and so, we don't need to include the path in the navigate call. If we want to be explicit, we can use path=\"./\" or path=\"/dashboard\" . By default, if the query parameters change, the page will not be reloaded. When the query parameters change, we can listen for the query_changed event and update our page state accordingly.","title":"Navigating"},{"location":"routes/query/#parsing-query-parameters","text":"Since query parameters are encoded in the url, we may need to decode them. It's also generally a good idea to ignore unknown query parameters and provide sensible defaults if any are missing, or incorrect. This provides a better user experience. from routing.router import Route class DashboardRoute(Route): path = \"/dashboard\" form = \"Pages.Dashboard\" def parse_query(self, query): valid_tabs = [\"income\", \"expenses\"] tab = query.get(\"tab\", \"income\") if tab not in valid_tabs: tab = \"income\" return {\"tab\": tab}","title":"Parsing Query Parameters"},{"location":"routes/query/#using-a-query-validator","text":"You can use a validator library. And if the validator has a parse method, it can be used as the parse_query attribute. from anvil_extras import zod as z class DashboardRoute(Route): path = \"/dashboard\" form = \"Pages.Dashboard\" parse_query = z.typed_dict({ \"tab\": z.enum([\"income\", \"expenses\"]).catch(\"income\") })","title":"Using a query validator"},{"location":"routes/query/#query-encoding","text":"The routing library can encode any json-able object as a query parameter. Where a query parameter is a str , int , float , bool or None this will be flat. e.g. ?foo=bar&baz=1&eggs=true will be decoded as {\"foo\": \"bar\", \"baz\": 1, \"eggs\": True} . Note If you have numbers in your query parameters, but these should actually be strings, you can convert these to str in your parse_query method. For nested, json-able objects, i.e. lists and dicts , the routing library will encode the object as a json string.","title":"Query encoding"},{"location":"routes/query/#loading-a-new-instance-of-a-form","text":"By default the routing library will not load a new instance of a form when the query parameters change. If you wish to load a new instance of a form when certain query parameters change, you can use the loader_deps method. This method should return a dict of dependencies, which determine when a form and it's data should be loaded. The return value from loader_deps should be json-able. from routing.router import Route class DashboardRoute(Route): path = \"/dashboard\" form = \"DashboardForm\" def loader_deps(self, **loader_args): # this ensures that whenever the `tab` changes a new instance of the form is loaded query = loader_args[\"query\"] return {\"tab\": query[\"tab\"]} For more details on loader_deps see the data loading section.","title":"Loading a new instance of a form"},{"location":"routes/redirecting/","text":"Redirecting \u00b6 You can redirect to a different route by raising a Redirect exception in a route's before_load method. from routing.router import Route, Redirect class IndexRoute(Route): path = \"/\" def before_load(self, **loader_args): raise Redirect(path=\"/dashboard\") In the above example, the user will be redirected to the /dashboard route when they navigate to your app. A common use case for redirecting is to ensure that a user is logged in before navigating to a route. from routing.router import Route, Redirect import anvil.users class IndexRoute(Route): path = \"/\" def before_load(self, **loader_args): if anvil.users.get_user(): raise Redirect(path=\"/dashboard\") else: raise Redirect(path=\"/login\") class EnsureUserMixin: def before_load(self, **loader_args): if not anvil.users.get_user(): raise Redirect(path=\"/login\") class DashboardRoute(EnsureUserMixin, Route): path = \"/dashboard\" form = \"Pages.Dashboard\" Note A determined user will be able to bypass the redirect by opening the form directly. Always ensure you check the user is logged in on the server before sending sensitive data to the client.","title":"Redirecting"},{"location":"routes/redirecting/#redirecting","text":"You can redirect to a different route by raising a Redirect exception in a route's before_load method. from routing.router import Route, Redirect class IndexRoute(Route): path = \"/\" def before_load(self, **loader_args): raise Redirect(path=\"/dashboard\") In the above example, the user will be redirected to the /dashboard route when they navigate to your app. A common use case for redirecting is to ensure that a user is logged in before navigating to a route. from routing.router import Route, Redirect import anvil.users class IndexRoute(Route): path = \"/\" def before_load(self, **loader_args): if anvil.users.get_user(): raise Redirect(path=\"/dashboard\") else: raise Redirect(path=\"/login\") class EnsureUserMixin: def before_load(self, **loader_args): if not anvil.users.get_user(): raise Redirect(path=\"/login\") class DashboardRoute(EnsureUserMixin, Route): path = \"/dashboard\" form = \"Pages.Dashboard\" Note A determined user will be able to bypass the redirect by opening the form directly. Always ensure you check the user is logged in on the server before sending sensitive data to the client.","title":"Redirecting"},{"location":"routing-context/","text":"Routing Context \u00b6 A RoutingContext instance is passed to a form when it is instantiated. It provides information about the current route and the current navigation context. from ._anvil_designer import IndexTemplate from routing.router import RoutingContext class IndexTemplate(IndexTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.routing_context = routing_context self.init_components(**properties) Autocompletion Adding the RoutingContext type definition will allow anvil to show autocompletion for the routing_context property. Properties \u00b6 path The path for the current route. params The parameters for the current route. query The query parameters for the current route. hash The hash for the current route. deps The dependencies dict returned by the loader_deps method. nav_context The navigation context for the current route. This is a dict and can be set by passing a nav_context argument to the navigate method. (Or equivalently by setting the nav_context attribute on a NavLink / Anchor component). form_properties The form properties for the current route. This is a dict and can be set by passing a form_properties argument to the navigate method. (Or equivalently by setting the form_properties attribute on the NavLink / Anchor component). Note the form_properties are passed as keyword arguments when instantiating a form. For more details see the Navigation section. error The error that occurred when loading the data, or the current route. This is particularly useful when displaying error messages in your error form. data The data for the current route. This is the value returned from the loader method. Events \u00b6 The RoutingContext instance will emit events when the route changes. data_loading Emitted when the data is loading. data_loaded Emitted when the data has been loaded. data_error Emitted when the data has an error. query_changed Emitted when the query parameters change. hash_changed Emitted when the hash changes.","title":"Routing Context"},{"location":"routing-context/#routing-context","text":"A RoutingContext instance is passed to a form when it is instantiated. It provides information about the current route and the current navigation context. from ._anvil_designer import IndexTemplate from routing.router import RoutingContext class IndexTemplate(IndexTemplate): def __init__(self, routing_context: RoutingContext, **properties): self.routing_context = routing_context self.init_components(**properties) Autocompletion Adding the RoutingContext type definition will allow anvil to show autocompletion for the routing_context property.","title":"Routing Context"},{"location":"routing-context/#properties","text":"path The path for the current route. params The parameters for the current route. query The query parameters for the current route. hash The hash for the current route. deps The dependencies dict returned by the loader_deps method. nav_context The navigation context for the current route. This is a dict and can be set by passing a nav_context argument to the navigate method. (Or equivalently by setting the nav_context attribute on a NavLink / Anchor component). form_properties The form properties for the current route. This is a dict and can be set by passing a form_properties argument to the navigate method. (Or equivalently by setting the form_properties attribute on the NavLink / Anchor component). Note the form_properties are passed as keyword arguments when instantiating a form. For more details see the Navigation section. error The error that occurred when loading the data, or the current route. This is particularly useful when displaying error messages in your error form. data The data for the current route. This is the value returned from the loader method.","title":"Properties"},{"location":"routing-context/#events","text":"The RoutingContext instance will emit events when the route changes. data_loading Emitted when the data is loading. data_loaded Emitted when the data has been loaded. data_error Emitted when the data has an error. query_changed Emitted when the query parameters change. hash_changed Emitted when the hash changes.","title":"Events"},{"location":"theme/","text":"","title":"Index"}]}